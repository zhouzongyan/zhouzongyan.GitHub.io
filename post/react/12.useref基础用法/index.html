<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.123.7"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="12 useRef基础用法"><meta itemprop=description content="保持简单的易用性和强大的功能。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://chn.gg/images/logo.jpg"><meta itemprop=keywords content="React,Java,Go,SQL"><meta property="og:type" content="article"><meta property="og:title" content="12 useRef基础用法"><meta property="og:description" content="保持简单的易用性和强大的功能。"><meta property="og:image" content="/images/logo.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://chn.gg/post/react/12.useref%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"><meta property="og:site_name" content="热爱生活与梦想"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Allen"><meta property="article:published_time" content="2023-09-12 14:48:15 +0000 UTC"><meta property="article:modified_time" content="2023-09-12 14:48:15 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.e0a6351e3c656c8120896640032aab320a6a302dcfd03cde96028362edadbfa8.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"12.useref%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95","permalink":"https://chn.gg/post/react/12.useref%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/","title":"12 useRef基础用法","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>12 useRef基础用法 - 热爱生活与梦想</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>热爱生活与梦想</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>没有伞的孩子要学会努力奔跑 ✊</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-go"><a href=/categories/go/ class=hvr-icon-pulse rel=section><i class="fa fa-go hvr-icon"></i>go</a></li><li class="menu-item menu-item-react"><a href=/categories/react/ class=hvr-icon-pulse rel=section><i class="fa fa-react hvr-icon"></i>React</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>33</span></a></li><li class="menu-item menu-item-rust"><a href=/categories/rust/ class=hvr-icon-pulse rel=section><i class="fa fa-rust hvr-icon"></i>Rust</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#useref概念解释>useRef概念解释</a><ul><li><ul><li></li></ul></li></ul></li><li><a href=#useref是来解决什么问题的>useRef是来解决什么问题的？</a></li><li><a href=#注意注意>注意注意</a></li><li><a href=#特别注意修改-current-的值并不会触发组件重新渲染>特别注意：修改 .current 的值并不会触发组件重新渲染</a></li><li><a href=#useref函数源码>useRef函数源码：</a></li><li><a href=#useref基本用法>useRef基本用法</a><ul><li><ul><li></li><li><a href=#ref补充说明>&lsquo;ref&rsquo;补充说明</a></li><li><a href=#xxx补充说明>&lsquo;&lt;xxx>&lsquo;补充说明</a></li><li><a href=#xxxrefcurrent补充说明>&lsquo;xxxRef.current&rsquo;补充说明</a></li></ul></li></ul></li><li><a href=#useref使用示例1>useRef使用示例1：</a></li><li><a href=#useref使用示例2>useRef使用示例2：</a></li><li><a href=#useref使用示例3父组件调用子组件中的函数>useRef使用示例3：父组件调用子组件中的函数</a><ul><li><ul><li><a href=#在-typescript-中使用-useref-创建计时器注意事项>在 TypeScript 中使用 useRef 创建计时器注意事项：</a></li><li><a href=#在-typescript-中给-userefcurrent-赋值的注意事项>在 TypeScript 中给 useRef.current 赋值的注意事项</a></li></ul></li></ul></li><li><a href=#那如何勾住自定义组件中的小写开头的类似原生标签的组件>那如何“勾住”自定义组件中的“小写开头的类似原生标签的组件”？</a><ul><li><ul><li></li></ul></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Allen src=/imgs/img-lazy-loading.gif data-src=/images/logo.jpg><p class=site-author-name itemprop=name>Allen</p><div class=site-description itemprop=description>保持简单的易用性和强大的功能。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>33</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>6</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>9</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/zhouzongyan title="Github → https://github.com/zhouzongyan" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/iningmeng title="知乎 → https://www.zhihu.com/people/iningmeng" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2023-05-15T20:29:27+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=73791></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=163></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2024-06-04T09:12:25+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/zhouzongyan rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg>
</a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://chn.gg/post/react/12.useref%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/images/logo.jpg"><meta itemprop=name content="Allen"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Allen"><meta itemprop=description content="保持简单的易用性和强大的功能。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="12 useRef基础用法"><meta itemprop=description content="12 useRef基础用法 useRef概念解释 我们第七个要学习的Hook(钩子函数)是useRef，他的作用是“勾住”某些组件挂载完成或重新渲染"></span><header class=post-header><h1 class=post-title itemprop="name headline">12 useRef基础用法</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-09-12 14:48:15 +0000 UTC" itemprop="dateCreated datePublished" datetime="2023-09-12 14:48:15 +0000 UTC">2023-09-12
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/react itemprop=url rel=index><span itemprop=name>react</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>7340</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>15分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/react/12.useref%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=12-useref基础用法>12 useRef基础用法
<a class=header-anchor href=#12-useref%e5%9f%ba%e7%a1%80%e7%94%a8%e6%b3%95></a></h1><h2 id=useref概念解释>useRef概念解释
<a class=header-anchor href=#useref%e6%a6%82%e5%bf%b5%e8%a7%a3%e9%87%8a></a></h2><p>我们第七个要学习的Hook(钩子函数)是useRef，他的作用是“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象，并返回该对象的引用。该引用在组件整个生命周期中都固定不变，该引用并不会随着组件重新渲染而失效。</p><p>上面这段话，就算你认真读几遍，估计也是一头雾水，到底说的是啥？<br>我也实在想不出其他更加通俗的语言来描述useRef，不过经过下面的详细分解描述，相信能帮到你来理解useRef。</p><h5 id=某些组件挂载完成或重新渲染完成后才拥有的某些对象>“某些组件挂载完成或重新渲染完成后才拥有的某些对象”：
<a class=header-anchor href=#%e6%9f%90%e4%ba%9b%e7%bb%84%e4%bb%b6%e6%8c%82%e8%bd%bd%e5%ae%8c%e6%88%90%e6%88%96%e9%87%8d%e6%96%b0%e6%b8%b2%e6%9f%93%e5%ae%8c%e6%88%90%e5%90%8e%e6%89%8d%e6%8b%a5%e6%9c%89%e7%9a%84%e6%9f%90%e4%ba%9b%e5%af%b9%e8%b1%a1></a></h5><p>这句话中的“某些对象”主要分为3种：JSX组件转换后对应的真实DOM对象、在useEffect中创建的变量、子组件内自定义的函数(方法)。</p><p><strong>第1：JSX组件转换后对应的真实DOM对象</strong>：<br>举例：假设在JSX中，有一个输入框&lt;input type=&lsquo;text&rsquo; />，这个标签最终将编译转换成真正的html标签中的&lt;input type=&lsquo;text&rsquo;/>。<br>你应该知道以下几点：<br>1、JSX中小写开头的组件看似和原生html标签相似，但是并不是真的原生标签，依然是react内置组件。<br>2、什么时候转换？ 虚拟DOM转化为真实DOM<br>3、什么时候可访问？组件挂载完成或重新渲染完成后</p><p>对于上面举例中的那个转换后的&lt;input/> 真实DOM，只有组件挂载完成或重新渲染完成后才可以访问，它就就属于“某些组件挂载完成或重新渲染完成后才拥有的某些对象”。</p><p>特别强调：useRef只适合“勾住”小写开头的类似原生标签的组件。如果是自定义的react组件(自定义的组件必须大写字母开头)，那么是无法使用useRef的。</p><p>思考：如何获取这个 &lt;input/> 真实DOM呢？<br>答：用useRef。</p><p><strong>第2：在useEffect中创建的变量</strong>：<br>举例，请看以下代码：</p><pre><code>useEffect(() =&gt; {
    let timer = setInterval(() =&gt; {
        setCount(prevData =&gt; prevData +1);
    }, 1000);
    return () =&gt; {
        clearInterval(timer);
    }
},[]);
</code></pre><p>上述代码中，请注意这个timer是在useEffect中才定义的。</p><p>思考：useEffect 以外的地方，该如何获取这个 timer 的引用？<br>答：用useRef</p><p><strong>第3：子组件内自定义的函数(方法)</strong><br>由于需要结合useImperativeHandle才可以实现，而useImperativeHandle目前还未学习，所以本章中不讨论这个怎么实现。<br>本章只讲前2中应用场景。</p><h5 id=并返回该对象的引用>“并返回该对象的引用”：
<a class=header-anchor href=#%e5%b9%b6%e8%bf%94%e5%9b%9e%e8%af%a5%e5%af%b9%e8%b1%a1%e7%9a%84%e5%bc%95%e7%94%a8></a></h5><p>上面的前2种情况，都提到用useRef来获取对象的引用。具体如何获取，稍后在useRef用法中会有演示。</p><h5 id=该引用在组件整个生命周期中都固定不变>“该引用在组件整个生命周期中都固定不变”：
<a class=header-anchor href=#%e8%af%a5%e5%bc%95%e7%94%a8%e5%9c%a8%e7%bb%84%e4%bb%b6%e6%95%b4%e4%b8%aa%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e4%b8%ad%e9%83%bd%e5%9b%ba%e5%ae%9a%e4%b8%8d%e5%8f%98></a></h5><p>假设通过useRef获得了该对象的引用，那么当react组件重新渲染后，如何保证该引用不丢失？<br>答：react在底层帮我们做了这个工作，我们只需要相信之前的引用可以继续找到目标对象即可。</p><p>请注意：React.createRef()也有useRef相似效果，但是React.createRef无法全部适用上面提到的3种情况。</p><p>让我们回到useRef基础学习中。</p><h2 id=useref是来解决什么问题的>useRef是来解决什么问题的？
<a class=header-anchor href=#useref%e6%98%af%e6%9d%a5%e8%a7%a3%e5%86%b3%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98%e7%9a%84></a></h2><p>答：useRef可以“获取某些组件挂载完成或重新渲染完成后才拥有的某些对象”的引用，且保证该引用在组件整个生命周期内固定不变，都能准确找到我们要找的对象。<br>具体已经在useRef中做了详细阐述，这里不再重复。</p><p>补充说明：<br>1、useRef是针对函数组件的，如果是类组件则使用React.createRef()。<br>2、React.createRef()也可以在函数组件中使用。<br>只不过React.createRef创建的引用不能保证每次重新渲染后引用固定不变。如果你只是使用React.createRef“勾住”JSX组件转换后对应的真实DOM对象是没问题的，但是如果想“勾住”在useEffect中创建的变量，那是做不到的。</p><p>2者都想可以“勾住”，只能使用useRef。</p><h2 id=注意注意>注意注意
<a class=header-anchor href=#%e6%b3%a8%e6%84%8f%e6%b3%a8%e6%84%8f></a></h2><p>在后面useImperativeHandle的学习中，你会知道useRef还可以 “勾住并调用” 子组件内定义的函数(方法)。</p><br><blockquote><p>以下内容更新于 2022.04.06</p></blockquote><h2 id=特别注意修改-current-的值并不会触发组件重新渲染>特别注意：修改 .current 的值并不会触发组件重新渲染
<a class=header-anchor href=#%e7%89%b9%e5%88%ab%e6%b3%a8%e6%84%8f%e4%bf%ae%e6%94%b9-current-%e7%9a%84%e5%80%bc%e5%b9%b6%e4%b8%8d%e4%bc%9a%e8%a7%a6%e5%8f%91%e7%bb%84%e4%bb%b6%e9%87%8d%e6%96%b0%e6%b8%b2%e6%9f%93></a></h2><p>在本文开头介绍 useRef 时用了这句话 “useRef 是“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象，并返回该对象的引用。”</p><p>也就是说 <strong>先有了 组件渲染，之后才更新了 useRef 中 .current 的值。</strong></p><blockquote><p>也就是说 useRef 变量的 current 的值实际上是 组件渲染 后的一个副产品。</p></blockquote><p><strong>这句话暗含了另外一层含义：主动更新 useRef 变量的 .current 的值并不会触发组件重新渲染。</strong></p><p>例如下面这个示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>import { useRef } from <span style=color:#e6db74>&#34;react&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> default function MyButton() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> countRef <span style=color:#f92672>=</span> useRef(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> handleClick <span style=color:#f92672>=</span> () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    countRef<span style=color:#f92672>.</span>current <span style=color:#f92672>=</span> countRef<span style=color:#f92672>.</span>current <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>&lt;</span>button onClick<span style=color:#f92672>=</span>{handleClick}<span style=color:#f92672>&gt;</span>Click me {countRef<span style=color:#f92672>.</span>current}<span style=color:#f92672>&lt;/</span>button<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>实际运行就会发现，在点击事件中我们修改了 countRef.current 的值，尽管该值确实发生了变化，可是并不会触发组件的重新渲染。</p><blockquote><p>使用 useState() 产生的变量值发生变化后，是会触发组件重新渲染的。</p></blockquote><br><blockquote><p>以上内容更新于 2022.04.06</p></blockquote><br><h2 id=useref函数源码>useRef函数源码：
<a class=header-anchor href=#useref%e5%87%bd%e6%95%b0%e6%ba%90%e7%a0%81></a></h2><p>回到useRef的学习中，首先看一下React源码中的
<a href=https://github.com/facebook/react/blob/master/packages/react/src/ReactHooks.js title=ReactHooks.js rel="noopener external nofollow noreferrer" target=_blank class=exturl>ReactHooks.js
<i class="fa fa-external-link-alt"></i>
</a>。</p><pre><code>//备注：源码采用TypeScript编写，如果不懂TS代码，阅读起来稍显困难
export function useRef&lt;T&gt;(initialValue: T): {|current: T|} {
  const dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
</code></pre><p>上述代码看不懂没关系，本系列教程只是讲述“如何使用Hook”，并不是“Hook源码分析”。^_^</p><h2 id=useref基本用法>useRef基本用法
<a class=header-anchor href=#useref%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95></a></h2><p>useRef(initialValue)函数只有1个可选参数，该参数为默认“勾住”的对象。绝大多数实际的情况是，默认“勾住”的对象在JSX未编译前(组件挂载或重新渲染后)根本不存在，所以更多时候都会传一个 null 作为默认值。如果不传任何参数，那么react默认将参数设置为undefined。</p><p>就目前本人所理解的，日常使用过程中useRef(null)和useRef() 实际上是没有什么区别的。</p><hr><p>以下更新于 2020.12.10</p><p><strong>补充一下 React + TypeScript 知识点：</strong></p><p>useRef(null) 和 useRef() 在 React + TypeScript 项目中还是有差别的。</p><p>假设我们要勾住一个 &lt;canvas /> DOM元素，那么：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#66d9ef>const</span> canvasRef1 <span style=color:#f92672>=</span> useRef<span style=color:#f92672>&lt;</span>HTMLCanvasElement<span style=color:#f92672>&gt;</span>(null)
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> canvasRef2 <span style=color:#f92672>=</span> useRef<span style=color:#f92672>&lt;</span>HTMLCanvasElement<span style=color:#f92672>&gt;</span>()
</span></span></code></pre></div><p>上面代码中：</p><ol><li>canvasRef1.current 的类型为：HTMLCanvasElement | null</li><li>canvasRef2.current 的类型为：HTMLCanvasElement | null | undefined</li></ol><p>以上更新于 2020.12.10</p><hr><p>第2遍强调：本文提到的组件，默认都是指小写开头的类似原生标签的组件，不可以是自定义组件。</p><p>接下来具体说说useRef关联对象的2种用法：<br>1、针对 JSX组件，通过属性 ref={xxxRef} 进行关联。<br>2、针对 useEffect中的变量，通过 xxxRef.current 进行关联。</p><h5 id=代码形式>代码形式：
<a class=header-anchor href=#%e4%bb%a3%e7%a0%81%e5%bd%a2%e5%bc%8f></a></h5><pre><code>//先定义一个xxRef引用变量，用于“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象
const xxRef = useRef(null);

//针对 JSX组件，通过属性 ref={xxxRef} 进行关联
&lt;xxx ref={xxRef} /&gt;

//针对 useEffect中的变量，通过 xxxRef.current 进行关联
useEffect(() =&gt; {
   xxRef.current = xxxxxx;
},[]);
</code></pre><h5 id=拆解说明>拆解说明：
<a class=header-anchor href=#%e6%8b%86%e8%a7%a3%e8%af%b4%e6%98%8e></a></h5><p>1、具体讲解已在上面示例代码中做了多项注释，此处不再重复；</p><h4 id=ref补充说明>&lsquo;ref&rsquo;补充说明
<a class=header-anchor href=#ref%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e></a></h4><p>1、组件的 ref 为特殊属性名，他并不存在组件属性传值的 props 中。<br>2、如果给一个组件设定了 ref 属性名，但是对应的值却不是由 useRef 创建的，那么实际运行中会收到react的报错，无法正常渲染。</p><h4 id=xxx补充说明>&lsquo;&lt;xxx>&lsquo;补充说明
<a class=header-anchor href=#xxx%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e></a></h4><p>1、useRef只能针对react中小写开头的类似原生标签的组件，所以这里用的是 &lt;xxx> 而不是 &lt;Xxx>。</p><h4 id=xxxrefcurrent补充说明>&lsquo;xxxRef.current&rsquo;补充说明
<a class=header-anchor href=#xxxrefcurrent%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e></a></h4><p>1、当需要使用“勾住”的对象时，也是通过xxRef.current来获取该对象的。</p><h2 id=useref使用示例1>useRef使用示例1：
<a class=header-anchor href=#useref%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b1></a></h2><p>若我们有一个组件，该组件只有一个输入框，我们希望当该组件挂载到网页后，自动获得输入焦点。</p><p>需求分析：<br>1、我们可以很轻松使用&lt;input >创建出这个输入框。<br>2、需要使用useRef “勾住”这个输入框，当它被挂载到网页后，通过操作原生html的方法，将焦点赋予该输入框上。</p><p>完整代码如下：</p><pre><code>import React,{useEffect,useRef} from 'react'

function Component() {
  //先定义一个inputRef引用变量，用于“勾住”挂载网页后的输入框
  const inputRef = useRef(null);

  useEffect(() =&gt; {
    //inputRef.current就是挂载到网页后的那个输入框，一个真实DOM，因此可以调用html中的方法focus()
    inputRef.current.focus();
  },[]);

  return &lt;div&gt;
      {/* 通过 ref 属性将 inputRef与该输入框进行“挂钩” */}
      &lt;input type='text' ref={inputRef} /&gt;
    &lt;/div&gt;
}
export default Component
</code></pre><p>注意：<br>1、在给组件设置 ref 属性时，只需传入 inputRef，千万不要传入 inputRef.current。<br>2、在“勾住”渲染后的真实DOM输入框后，能且只能调用原生html中该标签拥有的方法。</p><h2 id=useref使用示例2>useRef使用示例2：
<a class=header-anchor href=#useref%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b2></a></h2><p>若我们有一个组件，该组件的功能需求如下：<br>1、组件中有一个变量count，当该组件挂载到网页后，count每秒自动 +1。<br>2、组件中有一个按钮，点击按钮可以停止count自动+1。</p><p>需求分析：<br>1、声明内部变量count用 useState<br>2、可以在useEffect 通过setInterval创建一个计时器timer，实现count每秒自动 +1<br>3、当组件卸载前，需要通过 clearInterval 将timer清除<br>4、按钮点击处理函数中，也要通过 clearInterval 将timer清除</p><p>假设我们不使用useRef，那该如何实现？</p><p>为了确保timer可以被useEffect以外地方也能访问，我们通常做法是将timer声明提升到useEffect以外。<br>代码如下：</p><pre><code>import React,{useState,useEffect} from 'react'

function Component() {
  const [count,setCount] = useState(0);
  const [timer,setTimer] = useState(null); //单独声明定义timer，目的是为了让组件内所有地方都可以访问到timer

  useEffect(() =&gt; {
    //需要用setTimer()包裹住 setInterval()
    setTimer(setInterval(() =&gt; {
        setCount((prevData) =&gt; {return prevData +1});
    }, 1000));
    return () =&gt; {
      //清除掉timer
      clearInterval(timer);
    }
  },[]);

  const clickHandler = () =&gt; {
    //清除掉timer
    clearInterval(timer);
  };

  return (
    &lt;div&gt;
        {count}
        &lt;button onClick={clickHandler} &gt;stop&lt;/button&gt;
    &lt;/div&gt;
  )
}

export default Component
</code></pre><p>如果使用useRef，该如何实现？
代码如下：</p><pre><code>import React,{useState,useEffect,useRef} from 'react'

function Component() {
  const [count,setCount] =  useState(0);
  const timerRef = useRef(null);//先定义一个timerRef引用变量，用于“勾住”useEffect中通过setIntervale创建的计时器

  useEffect(() =&gt; {
    //将timerRef.current与setIntervale创建的计时器进行“挂钩”
    timerRef.current = setInterval(() =&gt; {
        setCount((prevData) =&gt; { return prevData +1});
    }, 1000);
    return () =&gt; {
        //通过timerRef.current，清除掉计时器
        clearInterval(timerRef.current);
    }
  },[]);

  const clickHandler = () =&gt; {
    //通过timerRef.current，清除掉计时器
    clearInterval(timerRef.current);
  };

  return (
    &lt;div&gt;
        {count}
        &lt;button onClick={clickHandler} &gt;stop&lt;/button&gt;
    &lt;/div&gt;
  )
}

export default Component
</code></pre><p><strong>两种实现方式对比：</strong></p><p>1、两种实现方式最主要的差异地方在于 如何创建组件内对计时器的引用。<br>2、两种创建引用的方式，分别是：用useState创建的timer、用useRef创建的timerRef<br>3、在使用setInterval时，相对来说timerRef.current更加好用简单，结构清晰，不需要像 setTimer那样需要再多1层包裹。<br>4、timer更像是一种react对计时器的映射，而timerRef直接就是真实DOM中计时器的引用，timerRef能够调用更多的原生html中的JS方法和属性。</p><p><strong>结论：</strong><br>1、如果需要对渲染后的DOM节点进行操作，必须使用useRef。<br>2、如果需要对渲染后才会存在的变量对象进行某些操作，建议使用useRef。</p><p>第3遍强调：useRef只适合“勾住”小写开头的类似原生标签的组件。如果是自定义的react组件(自定义的组件必须大写字母开头)，那么是无法使用useRef的。</p><br><blockquote><p>以下内容更新于 2022.05.20</p></blockquote><h2 id=useref使用示例3父组件调用子组件中的函数>useRef使用示例3：父组件调用子组件中的函数
<a class=header-anchor href=#useref%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b3%e7%88%b6%e7%bb%84%e4%bb%b6%e8%b0%83%e7%94%a8%e5%ad%90%e7%bb%84%e4%bb%b6%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0></a></h2><p><strong>首先特别强调：除非情况非常特殊，否则一般情况下都不要采用 父组件调用子组件的函数 这种策略。</strong></p><br><p><strong>使用 useRef 实现父组件调用子组件中的函数 实现思路：</strong></p><ol><li><p>父组件中通过 useRef 定义一个钩子变量，例如 childFunRef</p></li><li><p>父组件通过参数配置，将 childFunRef 传递给子组件</p></li><li><p>子组件在自己的 useEffect() 中定义一个函数，例如 doSomting()</p><blockquote><p>划重点：一定要在 useEffect() 中定义 doSomting()，不能直接在子组件内部定义。</p><p>因为如果 doSomting() 定义在子组件内部，那么就会造成每一次组件刷新都会重新生成一份 doSomthing()</p></blockquote></li><li><p>然后将 doSomting() 赋值到 childFunRef.current 中</p></li><li><p>这样，当父组件想调用子组件中的 doSomting() 时，可执行 childFunRef.current.doSomting()</p></li></ol><br><p>具体示例代码：</p><p><strong>ParentComponent</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>import { useRef } from <span style=color:#e6db74>&#34;react&#34;</span>;
</span></span><span style=display:flex><span>import ChildComponent from <span style=color:#e6db74>&#34;./child&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> ParentComponent <span style=color:#f92672>=</span> () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> childFunRef <span style=color:#f92672>=</span> useRef();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> handleOnClick <span style=color:#f92672>=</span> () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (childFunRef<span style=color:#f92672>.</span>current) {
</span></span><span style=display:flex><span>      childFunRef<span style=color:#f92672>.</span>current<span style=color:#f92672>.</span>doSomething();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span>div<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span>ChildComponent funRef<span style=color:#f92672>=</span>{childFunRef} <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span>button onClick<span style=color:#f92672>=</span>{handleOnClick}<span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>执行子项的</span>doSomething()<span style=color:#f92672>&lt;/</span>button<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/</span>div<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> default ParentComponent;
</span></span></code></pre></div><br><p><strong>ChildComponent</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>import { useEffect, useState } from <span style=color:#e6db74>&#34;react&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> ChildComponent <span style=color:#f92672>=</span> ({ funRef }) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> [num, setNum] <span style=color:#f92672>=</span> useState(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  useEffect(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> doSomething <span style=color:#f92672>=</span> () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      setNum(Math<span style=color:#f92672>.</span>floor(Math<span style=color:#f92672>.</span>random() <span style=color:#f92672>*</span> <span style=color:#ae81ff>100</span>));
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    funRef<span style=color:#f92672>.</span>current <span style=color:#f92672>=</span> { doSomething }; <span style=color:#f92672>//</span><span style=color:#960050;background-color:#1e0010>在子组件中修改父组件中定义的</span>childFunRef的值
</span></span><span style=display:flex><span>  }, [funRef]);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>&lt;</span>div<span style=color:#f92672>&gt;</span>{num}<span style=color:#f92672>&lt;/</span>div<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> default ChildComponent;
</span></span></code></pre></div><br><p><strong>特别说明：</strong></p><ol><li><p>下一章要讲解的 useImperativeHandle 也是用来实现 父组件调用子组件内定义的函数的。</p></li><li><p>再次强调，如非必要，真的不要使用 父组件调用子组件内函数 这种策略。</p><blockquote><p>最近我遇到了一个需求，子组件是一个第三方写好的轮播图，父组件需要调用这个轮播图的 next() 的函数来切换下一张，所以才使用了这种策略。</p></blockquote></li></ol><blockquote><p>以上内容更新于 2022.05.20</p></blockquote><br><hr><blockquote><p>以下内容更新于2020.11.18</p></blockquote><h4 id=在-typescript-中使用-useref-创建计时器注意事项>在 TypeScript 中使用 useRef 创建计时器注意事项：
<a class=header-anchor href=#%e5%9c%a8-typescript-%e4%b8%ad%e4%bd%bf%e7%94%a8-useref-%e5%88%9b%e5%bb%ba%e8%ae%a1%e6%97%b6%e5%99%a8%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9></a></h4><p>在上面代码示例中，请注意这一行代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>timerRef.current = setInterval(() =&gt; {
</span></span><span style=display:flex><span>        setCount((prevData) =&gt; { return prevData +1});
</span></span><span style=display:flex><span>    }, 1000);
</span></span></code></pre></div><p>如果是在 TS 语法下，上面的代码会报错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>不能将类型“Timeout”分配给类型“number”。
</span></span></code></pre></div><p><strong>Timeout ???</strong></p><p>造成这个错误提示的原因是：</p><ol><li>TypeScript 是运行在 Nodejs 环境下的，TS 编译之后的代码是运行在浏览器环境下的。</li><li>Nodejs 和浏览器中的 window 他们各自实现了一套自己的 setInterval</li><li>原来代码 timerRef.current = setInterval( &mldr; ) 中 setInterval 会被 TS 认为是 Nodejs 定义的 setInterval，而 Nodejs 中 setInterval 返回的类型就是 NodeJS.Timeout。</li><li>所以，我们需要将上述代码修改为：timerRef.current = window.setInterval( &mldr; )，明确我们调用的是 window.setInterval，而不是 Nodejs 的 setInterval。</li></ol><p><strong>附一个 TS 代码示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>import React, { useRef, useEffect } from <span style=color:#e6db74>&#39;react&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> MyTemp <span style=color:#f92672>=</span> () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> timer <span style=color:#f92672>=</span> useRef<span style=color:#f92672>&lt;</span>number <span style=color:#f92672>|</span> undefined<span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useEffect(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        timer<span style=color:#f92672>.</span>current <span style=color:#f92672>=</span> window<span style=color:#f92672>.</span>setInterval(() <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            console<span style=color:#f92672>.</span>log(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        }, <span style=color:#ae81ff>1000</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> () <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            clearInterval(timer<span style=color:#f92672>.</span>current)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;</span>div<span style=color:#f92672>&gt;&lt;/</span>div<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> default MyTemp
</span></span></code></pre></div><blockquote><p>以上内容更新于2020.11.18</p></blockquote><hr><blockquote><p>以下内容更新于2020.12.03</p></blockquote><h4 id=在-typescript-中给-userefcurrent-赋值的注意事项>在 TypeScript 中给 useRef.current 赋值的注意事项
<a class=header-anchor href=#%e5%9c%a8-typescript-%e4%b8%ad%e7%bb%99-userefcurrent-%e8%b5%8b%e5%80%bc%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9></a></h4><p>在 jsx 文件中，以下代码是不会有问题的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#66d9ef>const</span> myRef <span style=color:#f92672>=</span> useRef(null)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>myRef<span style=color:#f92672>.</span>current <span style=color:#f92672>=</span> xxxx
</span></span></code></pre></div><p>但是，在我们使用 TypeScript 之后，按照习惯改成以下代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#66d9ef>const</span> myRef <span style=color:#f92672>=</span> useRef<span style=color:#f92672>&lt;</span>Xxx<span style=color:#f92672>&gt;</span>(null)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>myRef<span style=color:#f92672>.</span>current <span style=color:#f92672>=</span> xxx
</span></span></code></pre></div><p>此时，会收到 TypeScript 的报错：<strong>无法分配到 &ldquo;current&rdquo; ，因为 myRef.current 是只读属性。</strong></p><p><strong>报错原因：</strong></p><p>React 的作者并没有规定使用 useRef(null) 之后 myRef.current 就不可以再修改了。</p><p>但是 TypeScript 的作者认为，若使用 useRef(null) 之后，myRef 就应该交由 React 来托管，外界不应该有权利去修改 myRef.current，因此此时会把 myRef.current 当做只读属性。</p><p><strong>解决方式：</strong></p><p>解决方式1：不给 useRef 设置 null 这个默认值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#66d9ef>const</span> myRef <span style=color:#f92672>=</span> useRef<span style=color:#f92672>&lt;</span>Xxx<span style=color:#f92672>&gt;</span>()
</span></span></code></pre></div><p>解决方式2：就是将原本的类型定义，修改成以下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#66d9ef>const</span> myRef <span style=color:#f92672>=</span> useRef<span style=color:#f92672>&lt;</span>Xxx <span style=color:#f92672>|</span> null<span style=color:#f92672>&gt;</span>(null)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>//</span><span style=color:#960050;background-color:#1e0010>或者是</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> myRef <span style=color:#f92672>=</span> useRef<span style=color:#f92672>&lt;</span>Xxx <span style=color:#f92672>|</span> undefined<span style=color:#f92672>&gt;</span>()
</span></span></code></pre></div><p>myRef.current 的数据类型，除了 Xxx 之外，再加上 null 或 undefined ，这样 TypeScript 就认为 myRef.current 可能中途会发生修改，因此不会再将其设置为只读属性，此时再去执行 <code>myRef.current = xxx</code> 不再会报错。</p><p><strong>验证一下：</strong></p><p>我们再去看看上面 2020.11.18 更新的 TypeScript 代码示例中：</p><p>由于将来需要执行 timer.current = window.setInterval ( &mldr; )，也就是说需要给 timer.current 赋值。</p><p>所以在定义时就使用以下方式，以确保 timer.current 不会被 TS 认为是只读属性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#66d9ef>const</span> timer <span style=color:#f92672>=</span> useRef<span style=color:#f92672>&lt;</span>number <span style=color:#f92672>|</span> undefined<span style=color:#f92672>&gt;</span>()
</span></span></code></pre></div><blockquote><p>以上内容更新于2020.12.03</p></blockquote><hr><h2 id=那如何勾住自定义组件中的小写开头的类似原生标签的组件>那如何“勾住”自定义组件中的“小写开头的类似原生标签的组件”？
<a class=header-anchor href=#%e9%82%a3%e5%a6%82%e4%bd%95%e5%8b%be%e4%bd%8f%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bb%84%e4%bb%b6%e4%b8%ad%e7%9a%84%e5%b0%8f%e5%86%99%e5%bc%80%e5%a4%b4%e7%9a%84%e7%b1%bb%e4%bc%bc%e5%8e%9f%e7%94%9f%e6%a0%87%e7%ad%be%e7%9a%84%e7%bb%84%e4%bb%b6></a></h2><p>答：使用React.forwardRef()。</p><h5 id=你是否思考过这个问题自定义组件到底是什么>你是否思考过这个问题：自定义组件到底是什么？
<a class=header-anchor href=#%e4%bd%a0%e6%98%af%e5%90%a6%e6%80%9d%e8%80%83%e8%bf%87%e8%bf%99%e4%b8%aa%e9%97%ae%e9%a2%98%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bb%84%e4%bb%b6%e5%88%b0%e5%ba%95%e6%98%af%e4%bb%80%e4%b9%88></a></h5><p>首先看一下“小写开头的类似原生标签的组件”，例如&lt;button>、&lt;input >，我们很容易理解他是react内置的类似原生DOM的组件，最终都将直接转换成对应的真实DOM。</p><p>那自定义组件又该如何理解，如何定义呢？</p><p>假设我们有一个自定义组件&lt;MyComponent>，那么有以下几点是可以肯定的：<br>1、&lt;MyComponent>内部return出去的，可以是小写开头的类似原生标签的组件，也可以是其他自定义组件。<br>2、无论嵌套多少次，最底层组件return出去的，一定是小写开头的类似原生标签的组件。<br>3、&lt;MyComponent>内部一定创建了变量、处理函数等等。<br>4、挂载或渲染后的实际网页中，并不会存在&lt;MyComponent>这个标签，存在的依然是各种原生html标签。</p><p>为了简化更加容易理解，暂时姑且先把“小写开头的类似原生标签的组件”直接当做“原生html标签”。<br>那么“自定义组件”和“原生html标签”究竟区别在哪里呢？</p><p>先不回答这个问题，再说另外一个问题：交互式html页面都有哪些构成？<br>答：有各种html标签 + JS对象(JS中定义的变量和函数)</p><p>那我们使用react开发页面，“原生html标签”有了，那还缺什么？ 当然是 JS对象(JS中定义的变量和函数)。</p><p>再回顾一下问题：“自定义组件”和“原生html标签”究竟区别在哪里呢？<br>答：“自定义组件”除了拥有“原生html标签”，还拥有JS对象(JS中定义的变量和函数)。</p><p>再回顾一下开始的疑问：自定义组件到底是什么？<br>答：其实根本不存在自定义组件，所谓自定义组件，只不过是react给我们的各种语法糖，react并没有创造另外一门语言，react整体就是原生JS的语法糖。</p><p>JSX语法 + Hook 组合起来，形成一个强大的语法糖，让你编写html标签和JS更加简便而已。
语法糖的对象就是：原生html标签 + JS对象(JS中定义的变量和函数)。</p><p>这就解释了为啥自定义组件 return 出去的内容，最外层必须有一个原生html标签。 说白了，无论你怎么定义，折腾这个自定义组件，本质上都要保证这个自定义组件最终都能转换成一段原生html代码。</p><p>上面这一大段话都是“简单到不能再简单的道理”，但是你只有理解透这一层，理解自定义组件、理解react究竟是什么之后，你会对于学习React各种API和Hook才会更加容易理解和接受。</p><p>让我们回到 那如何“勾住”自定义组件中的“小写开头的类似原生标签的组件”？ 这个问题上来。</p><h5 id=reactforwardref-的具体用法>React.forwardRef() 的具体用法
<a class=header-anchor href=#reactforwardref-%e7%9a%84%e5%85%b7%e4%bd%93%e7%94%a8%e6%b3%95></a></h5><p>React.forwardRef()包裹住要输出的组件，且将第2个参数设置为 ref 即可，示例代码：</p><pre><code>import React from 'react'

const ChildComponent = React.forwardRef((props,ref) =&gt; {
  //子组件通过将第2个参数ref 添加到内部真正的“小写开头的类似原生标签的组件”中 
  return &lt;button ref={ref}&gt;{props.label}&lt;/button&gt;
});

/* 上面的子组件直接在父组件内定义了，如果子组件是单独的.js文件，则可以通过
   export default React.forwardRef(ChildComponent) 这种形式  */

function Forward() {
  const ref = React.useRef();//父组件定义一个ref
  const clickHandle = () =&gt;{
    console.log(ref.current);//父组件获得渲染后子组件中对应的DOM节点引用
  }
  return (
    &lt;div&gt;
        {/* 父组件通过给子组件添加属性 ref={ref} 将ref作为参数传递给子组件 */}
        &lt;ChildComponent label='child bt' ref={ref} /&gt;
        &lt;button onClick={clickHandle} &gt;get child bt ref&lt;/button&gt;
    &lt;/div&gt;
  )
}
export default Forward;
</code></pre><hr><p>至此，关于useRef()基础用法、React.forwardRef()已经讲完。 这2个函数的掌握，会对下一个要讲的Hook：useImperativeHandle 非常有用。</p></div><footer class=post-footer><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>
赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/images/alipay.png alt="Allen - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/images/wechat.png alt="Allen - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
12 useRef基础用法</li><li class=post-copyright-author><strong>本文作者： </strong>Allen</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://chn.gg/post/react/12.useref%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/ title="12 useRef基础用法">https://chn.gg/post/react/12.useref%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i>
</span><span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i>
</span><span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/react/13.useimperativehandle%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/ rel=next title="13 useImperativeHandle基础用法"><i class="fa fa-chevron-left"></i> 13 useImperativeHandle基础用法</a></div><div class="post-nav-prev post-nav-item"><a href=/post/react/11.usememo%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/ rel=prev title="11 useMemo基础用法">11 useMemo基础用法
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=giscus-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Allen</span></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":"DIC_kwDOJhNIsM4CeQrC","emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"zhouzongyan/zhouzongyan.github.io","repoid":"R_kgDOJhNIsA","theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://chn.gg/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o \n\n可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄\n(Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.0fb3547374c917d23a2e5f762b70f3698d20b46a01cc18c38f9c467aeffc99fc.js defer></script></body></html>
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>12 useRef基础用法 | Allen</title>
    <meta name="generator" content="VuePress 1.9.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="rust">
    <meta name="keywords" content="allen,,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.145d8473.css" as="style"><link rel="preload" href="/assets/js/app.6f8ed848.js" as="script"><link rel="preload" href="/assets/js/2.83be7545.js" as="script"><link rel="preload" href="/assets/js/19.eab216d3.js" as="script"><link rel="prefetch" href="/assets/js/10.5a3204f9.js"><link rel="prefetch" href="/assets/js/11.02768c01.js"><link rel="prefetch" href="/assets/js/12.2c0a6e69.js"><link rel="prefetch" href="/assets/js/13.aab6b678.js"><link rel="prefetch" href="/assets/js/14.099be2b5.js"><link rel="prefetch" href="/assets/js/15.a608c94d.js"><link rel="prefetch" href="/assets/js/16.e2819852.js"><link rel="prefetch" href="/assets/js/17.86af6682.js"><link rel="prefetch" href="/assets/js/18.c8537385.js"><link rel="prefetch" href="/assets/js/20.682aa922.js"><link rel="prefetch" href="/assets/js/21.219bb420.js"><link rel="prefetch" href="/assets/js/22.84ecdbb0.js"><link rel="prefetch" href="/assets/js/23.b55b7082.js"><link rel="prefetch" href="/assets/js/24.0828344e.js"><link rel="prefetch" href="/assets/js/25.c20d5ec5.js"><link rel="prefetch" href="/assets/js/26.06149e04.js"><link rel="prefetch" href="/assets/js/27.d221eed5.js"><link rel="prefetch" href="/assets/js/28.53082f18.js"><link rel="prefetch" href="/assets/js/29.eedb3a2c.js"><link rel="prefetch" href="/assets/js/3.136b0782.js"><link rel="prefetch" href="/assets/js/30.43e5e245.js"><link rel="prefetch" href="/assets/js/4.2e56199c.js"><link rel="prefetch" href="/assets/js/5.2ab3c7f2.js"><link rel="prefetch" href="/assets/js/6.fa34b130.js"><link rel="prefetch" href="/assets/js/7.9dab484c.js"><link rel="prefetch" href="/assets/js/8.d763ac36.js"><link rel="prefetch" href="/assets/js/9.845b950f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.145d8473.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="Allen" class="logo"> <span class="site-name can-hide">Allen</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/9088dd/" class="nav-link">rust</a></div><div class="nav-item"><a href="/pages/b63bcd/" class="nav-link">go</a></div><div class="nav-item"><a href="/pages/dfd26d/" class="nav-link">react</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/9088dd/" class="nav-link">rust</a></div><div class="nav-item"><a href="/pages/b63bcd/" class="nav-link">go</a></div><div class="nav-item"><a href="/pages/dfd26d/" class="nav-link">react</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/pages/dfd26d/" class="sidebar-link">01 React Hook 简介</a></li><li><a href="/pages/b364c0/" class="sidebar-link">02 useState基础用法</a></li><li><a href="/pages/0e215c/" class="sidebar-link">03 useState高级用法</a></li><li><a href="/pages/16dc88/" class="sidebar-link">04 useEffect基础用法</a></li><li><a href="/pages/b9c039/" class="sidebar-link">05 useEffect高级用法</a></li><li><a href="/pages/fd14d7/" class="sidebar-link">06 useContext基础用法</a></li><li><a href="/pages/15da39/" class="sidebar-link">07 useContext高级用法</a></li><li><a href="/pages/ab6774/" class="sidebar-link">08 useReducer基础用法</a></li><li><a href="/pages/fd7fdb/" class="sidebar-link">09 useReducer高级用法</a></li><li><a href="/pages/9d19f1/" class="sidebar-link">10 useCallback基础用法</a></li><li><a href="/pages/8b008f/" class="sidebar-link">11 useMemo基础用法</a></li><li><a href="/pages/4c9695/" aria-current="page" class="active sidebar-link">12 useRef基础用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/4c9695/#useref概念解释" class="sidebar-link">useRef概念解释</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level5"><a href="/pages/4c9695/#某些组件挂载完成或重新渲染完成后才拥有的某些对象" class="sidebar-link">“某些组件挂载完成或重新渲染完成后才拥有的某些对象”：</a></li><li class="sidebar-sub-header level5"><a href="/pages/4c9695/#并返回该对象的引用" class="sidebar-link">“并返回该对象的引用”：</a></li><li class="sidebar-sub-header level5"><a href="/pages/4c9695/#该引用在组件整个生命周期中都固定不变" class="sidebar-link">“该引用在组件整个生命周期中都固定不变”：</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/4c9695/#useref是来解决什么问题的" class="sidebar-link">useRef是来解决什么问题的？</a></li><li class="sidebar-sub-header level2"><a href="/pages/4c9695/#注意注意" class="sidebar-link">注意注意</a></li><li class="sidebar-sub-header level2"><a href="/pages/4c9695/#特别注意-修改-current-的值并不会触发组件重新渲染" class="sidebar-link">特别注意：修改 .current 的值并不会触发组件重新渲染</a></li><li class="sidebar-sub-header level2"><a href="/pages/4c9695/#useref函数源码" class="sidebar-link">useRef函数源码：</a></li><li class="sidebar-sub-header level2"><a href="/pages/4c9695/#useref基本用法" class="sidebar-link">useRef基本用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level5"><a href="/pages/4c9695/#代码形式" class="sidebar-link">代码形式：</a></li><li class="sidebar-sub-header level5"><a href="/pages/4c9695/#拆解说明" class="sidebar-link">拆解说明：</a></li><li class="sidebar-sub-header level4"><a href="/pages/4c9695/#ref-补充说明" class="sidebar-link">'ref'补充说明</a></li><li class="sidebar-sub-header level4"><a href="/pages/4c9695/#xxx-补充说明" class="sidebar-link">''补充说明</a></li><li class="sidebar-sub-header level4"><a href="/pages/4c9695/#xxxref-current-补充说明" class="sidebar-link">'xxxRef.current'补充说明</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/4c9695/#useref使用示例1" class="sidebar-link">useRef使用示例1：</a></li><li class="sidebar-sub-header level2"><a href="/pages/4c9695/#useref使用示例2" class="sidebar-link">useRef使用示例2：</a></li><li class="sidebar-sub-header level2"><a href="/pages/4c9695/#useref使用示例3-父组件调用子组件中的函数" class="sidebar-link">useRef使用示例3：父组件调用子组件中的函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/pages/4c9695/#在-typescript-中使用-useref-创建计时器注意事项" class="sidebar-link">在 TypeScript 中使用 useRef 创建计时器注意事项：</a></li><li class="sidebar-sub-header level4"><a href="/pages/4c9695/#在-typescript-中给-useref-current-赋值的注意事项" class="sidebar-link">在 TypeScript 中给 useRef.current 赋值的注意事项</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/4c9695/#那如何-勾住-自定义组件中的-小写开头的类似原生标签的组件" class="sidebar-link">那如何“勾住”自定义组件中的“小写开头的类似原生标签的组件”？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level5"><a href="/pages/4c9695/#你是否思考过这个问题-自定义组件到底是什么" class="sidebar-link">你是否思考过这个问题：自定义组件到底是什么？</a></li><li class="sidebar-sub-header level5"><a href="/pages/4c9695/#react-forwardref-的具体用法" class="sidebar-link">React.forwardRef() 的具体用法</a></li></ul></li></ul></li><li><a href="/pages/ede426/" class="sidebar-link">13 useImperativeHandle基础用法</a></li><li><a href="/pages/1b392f/" class="sidebar-link">14 useLayoutEffect基础用法</a></li><li><a href="/pages/e1ebef/" class="sidebar-link">15 useDebugValue基础用法</a></li><li><a href="/pages/c38877/" class="sidebar-link">16 自定义hook</a></li><li><a href="/pages/621c1c/" class="sidebar-link">17 React Hook 总结</a></li><li><a href="/pages/a44117/" class="sidebar-link">18 示例：React使用Echarts所用到的hooks</a></li><li><a href="/pages/74a184/" class="sidebar-link">19 useTransition基础用法</a></li><li><a href="/pages/0116b5/" class="sidebar-link">20 React基础知识</a></li><li><a href="/pages/89216e/" class="sidebar-link">21 React扩展阅读</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>react</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="//github.183.co" target="_blank" title="作者" class="beLink" data-v-06225672>Allen</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-09-12</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">12 useRef基础用法<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><h1 id="_12-useref基础用法"><a href="#_12-useref基础用法" class="header-anchor">#</a> 12 useRef基础用法</h1> <h2 id="useref概念解释"><a href="#useref概念解释" class="header-anchor">#</a> useRef概念解释</h2> <p>我们第七个要学习的Hook(钩子函数)是useRef，他的作用是“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象，并返回该对象的引用。该引用在组件整个生命周期中都固定不变，该引用并不会随着组件重新渲染而失效。</p> <p>上面这段话，就算你认真读几遍，估计也是一头雾水，到底说的是啥？<br>
我也实在想不出其他更加通俗的语言来描述useRef，不过经过下面的详细分解描述，相信能帮到你来理解useRef。</p> <h5 id="某些组件挂载完成或重新渲染完成后才拥有的某些对象"><a href="#某些组件挂载完成或重新渲染完成后才拥有的某些对象" class="header-anchor">#</a> “某些组件挂载完成或重新渲染完成后才拥有的某些对象”：</h5> <p>这句话中的“某些对象”主要分为3种：JSX组件转换后对应的真实DOM对象、在useEffect中创建的变量、子组件内自定义的函数(方法)。</p> <p><strong>第1：JSX组件转换后对应的真实DOM对象</strong>：<br>
举例：假设在JSX中，有一个输入框&lt;input type='text' /&gt;，这个标签最终将编译转换成真正的html标签中的&lt;input type='text'/&gt;。<br>
你应该知道以下几点：<br>
1、JSX中小写开头的组件看似和原生html标签相似，但是并不是真的原生标签，依然是react内置组件。<br>
2、什么时候转换？ 虚拟DOM转化为真实DOM<br>
3、什么时候可访问？组件挂载完成或重新渲染完成后</p> <p>对于上面举例中的那个转换后的&lt;input/&gt; 真实DOM，只有组件挂载完成或重新渲染完成后才可以访问，它就就属于“某些组件挂载完成或重新渲染完成后才拥有的某些对象”。</p> <p>特别强调：useRef只适合“勾住”小写开头的类似原生标签的组件。如果是自定义的react组件(自定义的组件必须大写字母开头)，那么是无法使用useRef的。</p> <p>思考：如何获取这个 &lt;input/&gt; 真实DOM呢？<br>
答：用useRef。</p> <p><strong>第2：在useEffect中创建的变量</strong>：<br>
举例，请看以下代码：</p> <div class="language- extra-class"><pre><code>useEffect(() =&gt; {
    let timer = setInterval(() =&gt; {
        setCount(prevData =&gt; prevData +1);
    }, 1000);
    return () =&gt; {
        clearInterval(timer);
    }
},[]);
</code></pre></div><p>上述代码中，请注意这个timer是在useEffect中才定义的。</p> <p>思考：useEffect 以外的地方，该如何获取这个 timer 的引用？<br>
答：用useRef</p> <p><strong>第3：子组件内自定义的函数(方法)</strong><br>
由于需要结合useImperativeHandle才可以实现，而useImperativeHandle目前还未学习，所以本章中不讨论这个怎么实现。<br>
本章只讲前2中应用场景。</p> <h5 id="并返回该对象的引用"><a href="#并返回该对象的引用" class="header-anchor">#</a> “并返回该对象的引用”：</h5> <p>上面的前2种情况，都提到用useRef来获取对象的引用。具体如何获取，稍后在useRef用法中会有演示。</p> <h5 id="该引用在组件整个生命周期中都固定不变"><a href="#该引用在组件整个生命周期中都固定不变" class="header-anchor">#</a> “该引用在组件整个生命周期中都固定不变”：</h5> <p>假设通过useRef获得了该对象的引用，那么当react组件重新渲染后，如何保证该引用不丢失？<br>
答：react在底层帮我们做了这个工作，我们只需要相信之前的引用可以继续找到目标对象即可。</p> <p>请注意：React.createRef()也有useRef相似效果，但是React.createRef无法全部适用上面提到的3种情况。</p> <p>让我们回到useRef基础学习中。</p> <h2 id="useref是来解决什么问题的"><a href="#useref是来解决什么问题的" class="header-anchor">#</a> useRef是来解决什么问题的？</h2> <p>答：useRef可以“获取某些组件挂载完成或重新渲染完成后才拥有的某些对象”的引用，且保证该引用在组件整个生命周期内固定不变，都能准确找到我们要找的对象。<br>
具体已经在useRef中做了详细阐述，这里不再重复。</p> <p>补充说明：<br>
1、useRef是针对函数组件的，如果是类组件则使用React.createRef()。<br>
2、React.createRef()也可以在函数组件中使用。<br>
只不过React.createRef创建的引用不能保证每次重新渲染后引用固定不变。如果你只是使用React.createRef“勾住”JSX组件转换后对应的真实DOM对象是没问题的，但是如果想“勾住”在useEffect中创建的变量，那是做不到的。</p> <p>2者都想可以“勾住”，只能使用useRef。</p> <h2 id="注意注意"><a href="#注意注意" class="header-anchor">#</a> 注意注意</h2> <p>在后面useImperativeHandle的学习中，你会知道useRef还可以 “勾住并调用” 子组件内定义的函数(方法)。</p> <br> <blockquote><p>以下内容更新于 2022.04.06</p></blockquote> <h2 id="特别注意-修改-current-的值并不会触发组件重新渲染"><a href="#特别注意-修改-current-的值并不会触发组件重新渲染" class="header-anchor">#</a> 特别注意：修改 .current 的值并不会触发组件重新渲染</h2> <p>在本文开头介绍 useRef  时用了这句话 “useRef 是“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象，并返回该对象的引用。”</p> <p>也就是说 <strong>先有了 组件渲染，之后才更新了 useRef 中 .current 的值。</strong></p> <blockquote><p>也就是说 useRef 变量的 current 的值实际上是 组件渲染 后的一个副产品。</p></blockquote> <p><strong>这句话暗含了另外一层含义：主动更新 useRef 变量的 .current 的值并不会触发组件重新渲染。</strong></p> <p>例如下面这个示例：</p> <div class="language- extra-class"><pre class="language-text"><code>import { useRef } from &quot;react&quot;;

export default function MyButton() {
  const countRef = useRef(0)

  const handleClick = () =&gt; {
    countRef.current = countRef.current + 1
  };

  return &lt;button onClick={handleClick}&gt;Click me {countRef.current}&lt;/button&gt;;
}
</code></pre></div><p>实际运行就会发现，在点击事件中我们修改了 countRef.current 的值，尽管该值确实发生了变化，可是并不会触发组件的重新渲染。</p> <blockquote><p>使用 useState() 产生的变量值发生变化后，是会触发组件重新渲染的。</p></blockquote> <br> <blockquote><p>以上内容更新于 2022.04.06</p></blockquote> <br> <h2 id="useref函数源码"><a href="#useref函数源码" class="header-anchor">#</a> useRef函数源码：</h2> <p>回到useRef的学习中，首先看一下React源码中的<a href="https://github.com/facebook/react/blob/master/packages/react/src/ReactHooks.js" target="_blank" rel="noopener noreferrer">ReactHooks.js<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <div class="language- extra-class"><pre><code>//备注：源码采用TypeScript编写，如果不懂TS代码，阅读起来稍显困难
export function useRef&lt;T&gt;(initialValue: T): {|current: T|} {
  const dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
</code></pre></div><p>上述代码看不懂没关系，本系列教程只是讲述“如何使用Hook”，并不是“Hook源码分析”。^_^</p> <h2 id="useref基本用法"><a href="#useref基本用法" class="header-anchor">#</a> useRef基本用法</h2> <p>useRef(initialValue)函数只有1个可选参数，该参数为默认“勾住”的对象。绝大多数实际的情况是，默认“勾住”的对象在JSX未编译前(组件挂载或重新渲染后)根本不存在，所以更多时候都会传一个 null 作为默认值。如果不传任何参数，那么react默认将参数设置为undefined。</p> <p>就目前本人所理解的，日常使用过程中useRef(null)和useRef() 实际上是没有什么区别的。</p> <hr> <p>以下更新于 2020.12.10</p> <p><strong>补充一下 React + TypeScript 知识点：</strong></p> <p>useRef(null) 和 useRef() 在 React + TypeScript 项目中还是有差别的。</p> <p>假设我们要勾住一个 &lt;canvas /&gt; DOM元素，那么：</p> <div class="language- extra-class"><pre class="language-text"><code>const canvasRef1 = useRef&lt;HTMLCanvasElement&gt;(null)
const canvasRef2 = useRef&lt;HTMLCanvasElement&gt;()
</code></pre></div><p>上面代码中：</p> <ol><li>canvasRef1.current 的类型为：HTMLCanvasElement | null</li> <li>canvasRef2.current 的类型为：HTMLCanvasElement | null | undefined</li></ol> <p>以上更新于 2020.12.10</p> <hr> <p>第2遍强调：本文提到的组件，默认都是指小写开头的类似原生标签的组件，不可以是自定义组件。</p> <p>接下来具体说说useRef关联对象的2种用法：<br>
1、针对 JSX组件，通过属性 ref={xxxRef} 进行关联。<br>
2、针对 useEffect中的变量，通过 xxxRef.current 进行关联。</p> <h5 id="代码形式"><a href="#代码形式" class="header-anchor">#</a> 代码形式：</h5> <div class="language- extra-class"><pre><code>//先定义一个xxRef引用变量，用于“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象
const xxRef = useRef(null);

//针对 JSX组件，通过属性 ref={xxxRef} 进行关联
&lt;xxx ref={xxRef} /&gt;

//针对 useEffect中的变量，通过 xxxRef.current 进行关联
useEffect(() =&gt; {
   xxRef.current = xxxxxx;
},[]);
</code></pre></div><h5 id="拆解说明"><a href="#拆解说明" class="header-anchor">#</a> 拆解说明：</h5> <p>1、具体讲解已在上面示例代码中做了多项注释，此处不再重复；</p> <h4 id="ref-补充说明"><a href="#ref-补充说明" class="header-anchor">#</a> 'ref'补充说明</h4> <p>1、组件的 ref 为特殊属性名，他并不存在组件属性传值的 props 中。<br>
2、如果给一个组件设定了 ref 属性名，但是对应的值却不是由 useRef 创建的，那么实际运行中会收到react的报错，无法正常渲染。</p> <h4 id="xxx-补充说明"><a href="#xxx-补充说明" class="header-anchor">#</a> '&lt;xxx&gt;'补充说明</h4> <p>1、useRef只能针对react中小写开头的类似原生标签的组件，所以这里用的是 &lt;xxx&gt; 而不是 &lt;Xxx&gt;。</p> <h4 id="xxxref-current-补充说明"><a href="#xxxref-current-补充说明" class="header-anchor">#</a> 'xxxRef.current'补充说明</h4> <p>1、当需要使用“勾住”的对象时，也是通过xxRef.current来获取该对象的。</p> <h2 id="useref使用示例1"><a href="#useref使用示例1" class="header-anchor">#</a> useRef使用示例1：</h2> <p>若我们有一个组件，该组件只有一个输入框，我们希望当该组件挂载到网页后，自动获得输入焦点。</p> <p>需求分析：<br>
1、我们可以很轻松使用&lt;input &gt;创建出这个输入框。<br>
2、需要使用useRef “勾住”这个输入框，当它被挂载到网页后，通过操作原生html的方法，将焦点赋予该输入框上。</p> <p>完整代码如下：</p> <div class="language- extra-class"><pre><code>import React,{useEffect,useRef} from 'react'

function Component() {
  //先定义一个inputRef引用变量，用于“勾住”挂载网页后的输入框
  const inputRef = useRef(null);

  useEffect(() =&gt; {
    //inputRef.current就是挂载到网页后的那个输入框，一个真实DOM，因此可以调用html中的方法focus()
    inputRef.current.focus();
  },[]);

  return &lt;div&gt;
      {/* 通过 ref 属性将 inputRef与该输入框进行“挂钩” */}
      &lt;input type='text' ref={inputRef} /&gt;
    &lt;/div&gt;
}
export default Component
</code></pre></div><p>注意：<br>
1、在给组件设置 ref 属性时，只需传入 inputRef，千万不要传入 inputRef.current。<br>
2、在“勾住”渲染后的真实DOM输入框后，能且只能调用原生html中该标签拥有的方法。</p> <h2 id="useref使用示例2"><a href="#useref使用示例2" class="header-anchor">#</a> useRef使用示例2：</h2> <p>若我们有一个组件，该组件的功能需求如下：<br>
1、组件中有一个变量count，当该组件挂载到网页后，count每秒自动 +1。<br>
2、组件中有一个按钮，点击按钮可以停止count自动+1。</p> <p>需求分析：<br>
1、声明内部变量count用 useState<br>
2、可以在useEffect 通过setInterval创建一个计时器timer，实现count每秒自动 +1<br>
3、当组件卸载前，需要通过 clearInterval 将timer清除<br>
4、按钮点击处理函数中，也要通过 clearInterval 将timer清除</p> <p>假设我们不使用useRef，那该如何实现？</p> <p>为了确保timer可以被useEffect以外地方也能访问，我们通常做法是将timer声明提升到useEffect以外。<br>
代码如下：</p> <div class="language- extra-class"><pre><code>import React,{useState,useEffect} from 'react'

function Component() {
  const [count,setCount] = useState(0);
  const [timer,setTimer] = useState(null); //单独声明定义timer，目的是为了让组件内所有地方都可以访问到timer

  useEffect(() =&gt; {
    //需要用setTimer()包裹住 setInterval()
    setTimer(setInterval(() =&gt; {
        setCount((prevData) =&gt; {return prevData +1});
    }, 1000));
    return () =&gt; {
      //清除掉timer
      clearInterval(timer);
    }
  },[]);

  const clickHandler = () =&gt; {
    //清除掉timer
    clearInterval(timer);
  };

  return (
    &lt;div&gt;
        {count}
        &lt;button onClick={clickHandler} &gt;stop&lt;/button&gt;
    &lt;/div&gt;
  )
}

export default Component
</code></pre></div><p>如果使用useRef，该如何实现？
代码如下：</p> <div class="language- extra-class"><pre><code>import React,{useState,useEffect,useRef} from 'react'

function Component() {
  const [count,setCount] =  useState(0);
  const timerRef = useRef(null);//先定义一个timerRef引用变量，用于“勾住”useEffect中通过setIntervale创建的计时器

  useEffect(() =&gt; {
    //将timerRef.current与setIntervale创建的计时器进行“挂钩”
    timerRef.current = setInterval(() =&gt; {
        setCount((prevData) =&gt; { return prevData +1});
    }, 1000);
    return () =&gt; {
        //通过timerRef.current，清除掉计时器
        clearInterval(timerRef.current);
    }
  },[]);

  const clickHandler = () =&gt; {
    //通过timerRef.current，清除掉计时器
    clearInterval(timerRef.current);
  };

  return (
    &lt;div&gt;
        {count}
        &lt;button onClick={clickHandler} &gt;stop&lt;/button&gt;
    &lt;/div&gt;
  )
}

export default Component
</code></pre></div><p><strong>两种实现方式对比：</strong></p> <p>1、两种实现方式最主要的差异地方在于 如何创建组件内对计时器的引用。<br>
2、两种创建引用的方式，分别是：用useState创建的timer、用useRef创建的timerRef<br>
3、在使用setInterval时，相对来说timerRef.current更加好用简单，结构清晰，不需要像 setTimer那样需要再多1层包裹。<br>
4、timer更像是一种react对计时器的映射，而timerRef直接就是真实DOM中计时器的引用，timerRef能够调用更多的原生html中的JS方法和属性。</p> <p><strong>结论：</strong><br>
1、如果需要对渲染后的DOM节点进行操作，必须使用useRef。<br>
2、如果需要对渲染后才会存在的变量对象进行某些操作，建议使用useRef。</p> <p>第3遍强调：useRef只适合“勾住”小写开头的类似原生标签的组件。如果是自定义的react组件(自定义的组件必须大写字母开头)，那么是无法使用useRef的。</p> <br> <blockquote><p>以下内容更新于 2022.05.20</p></blockquote> <h2 id="useref使用示例3-父组件调用子组件中的函数"><a href="#useref使用示例3-父组件调用子组件中的函数" class="header-anchor">#</a> useRef使用示例3：父组件调用子组件中的函数</h2> <p><strong>首先特别强调：除非情况非常特殊，否则一般情况下都不要采用 父组件调用子组件的函数 这种策略。</strong></p> <br> <p><strong>使用 useRef 实现父组件调用子组件中的函数 实现思路：</strong></p> <ol><li><p>父组件中通过 useRef 定义一个钩子变量，例如 childFunRef</p></li> <li><p>父组件通过参数配置，将 childFunRef 传递给子组件</p></li> <li><p>子组件在自己的 useEffect() 中定义一个函数，例如 doSomting()</p> <blockquote><p>划重点：一定要在 useEffect() 中定义 doSomting()，不能直接在子组件内部定义。</p> <p>因为如果 doSomting() 定义在子组件内部，那么就会造成每一次组件刷新都会重新生成一份 doSomthing()</p></blockquote></li> <li><p>然后将 doSomting() 赋值到 childFunRef.current 中</p></li> <li><p>这样，当父组件想调用子组件中的 doSomting() 时，可执行 childFunRef.current.doSomting()</p></li></ol> <br> <p>具体示例代码：</p> <p><strong>ParentComponent</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import { useRef } from &quot;react&quot;;
import ChildComponent from &quot;./child&quot;;

const ParentComponent = () =&gt; {
  const childFunRef = useRef();
  const handleOnClick = () =&gt; {
    if (childFunRef.current) {
      childFunRef.current.doSomething();
    }
  };
  return (
    &lt;div&gt;
      &lt;ChildComponent funRef={childFunRef} /&gt;
      &lt;button onClick={handleOnClick}&gt;执行子项的doSomething()&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default ParentComponent;
</code></pre></div><br> <p><strong>ChildComponent</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import { useEffect, useState } from &quot;react&quot;;

const ChildComponent = ({ funRef }) =&gt; {
  const [num, setNum] = useState(0);
  useEffect(() =&gt; {
    const doSomething = () =&gt; {
      setNum(Math.floor(Math.random() * 100));
    };
    funRef.current = { doSomething }; //在子组件中修改父组件中定义的childFunRef的值
  }, [funRef]);
  return &lt;div&gt;{num}&lt;/div&gt;;
};

export default ChildComponent;
</code></pre></div><br> <p><strong>特别说明：</strong></p> <ol><li><p>下一章要讲解的 useImperativeHandle 也是用来实现 父组件调用子组件内定义的函数的。</p></li> <li><p>再次强调，如非必要，真的不要使用 父组件调用子组件内函数 这种策略。</p> <blockquote><p>最近我遇到了一个需求，子组件是一个第三方写好的轮播图，父组件需要调用这个轮播图的 next() 的函数来切换下一张，所以才使用了这种策略。</p></blockquote></li></ol> <blockquote><p>以上内容更新于 2022.05.20</p></blockquote> <br> <hr> <blockquote><p>以下内容更新于2020.11.18</p></blockquote> <h4 id="在-typescript-中使用-useref-创建计时器注意事项"><a href="#在-typescript-中使用-useref-创建计时器注意事项" class="header-anchor">#</a> 在 TypeScript 中使用 useRef 创建计时器注意事项：</h4> <p>在上面代码示例中，请注意这一行代码：</p> <div class="language- extra-class"><pre class="language-text"><code>timerRef.current = setInterval(() =&gt; {
        setCount((prevData) =&gt; { return prevData +1});
    }, 1000);
</code></pre></div><p>如果是在 TS 语法下，上面的代码会报错误：</p> <div class="language- extra-class"><pre class="language-text"><code>不能将类型“Timeout”分配给类型“number”。
</code></pre></div><p><strong>Timeout ???</strong></p> <p>造成这个错误提示的原因是：</p> <ol><li>TypeScript 是运行在 Nodejs 环境下的，TS 编译之后的代码是运行在浏览器环境下的。</li> <li>Nodejs 和浏览器中的 window 他们各自实现了一套自己的 setInterval</li> <li>原来代码 timerRef.current = setInterval( ... ) 中 setInterval 会被 TS 认为是 Nodejs 定义的 setInterval，而  Nodejs 中 setInterval 返回的类型就是 NodeJS.Timeout。</li> <li>所以，我们需要将上述代码修改为：timerRef.current = window.setInterval( ... )，明确我们调用的是 window.setInterval，而不是 Nodejs 的 setInterval。</li></ol> <p><strong>附一个 TS 代码示例：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import React, { useRef, useEffect } from 'react'

const MyTemp = () =&gt; {
    const timer = useRef&lt;number | undefined&gt;()

    useEffect(() =&gt; {
        timer.current = window.setInterval(() =&gt; {
            console.log(0)
        }, 1000)

        return () =&gt; {
            clearInterval(timer.current)
        }
    }, [])
    return (
        &lt;div&gt;&lt;/div&gt;
    )
}

export default MyTemp
</code></pre></div><blockquote><p>以上内容更新于2020.11.18</p></blockquote> <hr> <blockquote><p>以下内容更新于2020.12.03</p></blockquote> <h4 id="在-typescript-中给-useref-current-赋值的注意事项"><a href="#在-typescript-中给-useref-current-赋值的注意事项" class="header-anchor">#</a> 在 TypeScript 中给 useRef.current 赋值的注意事项</h4> <p>在 jsx 文件中，以下代码是不会有问题的。</p> <div class="language- extra-class"><pre class="language-text"><code>const myRef = useRef(null)
...
myRef.current = xxxx
</code></pre></div><p>但是，在我们使用 TypeScript 之后，按照习惯改成以下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>const myRef = useRef&lt;Xxx&gt;(null)
...
myRef.current = xxx
</code></pre></div><p>此时，会收到 TypeScript 的报错：<strong>无法分配到 &quot;current&quot; ，因为 myRef.current 是只读属性。</strong></p> <p><strong>报错原因：</strong></p> <p>React 的作者并没有规定使用 useRef(null) 之后 myRef.current 就不可以再修改了。</p> <p>但是 TypeScript 的作者认为，若使用 useRef(null) 之后，myRef 就应该交由 React 来托管，外界不应该有权利去修改 myRef.current，因此此时会把 myRef.current 当做只读属性。</p> <p><strong>解决方式：</strong></p> <p>解决方式1：不给 useRef 设置 null 这个默认值</p> <div class="language- extra-class"><pre class="language-text"><code>const myRef = useRef&lt;Xxx&gt;()
</code></pre></div><p>解决方式2：就是将原本的类型定义，修改成以下：</p> <div class="language- extra-class"><pre class="language-text"><code>const myRef = useRef&lt;Xxx | null&gt;(null)

//或者是

const myRef = useRef&lt;Xxx | undefined&gt;()
</code></pre></div><p>myRef.current 的数据类型，除了 Xxx 之外，再加上 null 或 undefined ，这样 TypeScript 就认为  myRef.current 可能中途会发生修改，因此不会再将其设置为只读属性，此时再去执行 <code>myRef.current = xxx</code> 不再会报错。</p> <p><strong>验证一下：</strong></p> <p>我们再去看看上面 2020.11.18 更新的 TypeScript 代码示例中：</p> <p>由于将来需要执行 timer.current =  window.setInterval ( ... )，也就是说需要给 timer.current 赋值。</p> <p>所以在定义时就使用以下方式，以确保 timer.current 不会被 TS 认为是只读属性：</p> <div class="language- extra-class"><pre class="language-text"><code>const timer = useRef&lt;number | undefined&gt;()
</code></pre></div><blockquote><p>以上内容更新于2020.12.03</p></blockquote> <hr> <h2 id="那如何-勾住-自定义组件中的-小写开头的类似原生标签的组件"><a href="#那如何-勾住-自定义组件中的-小写开头的类似原生标签的组件" class="header-anchor">#</a> 那如何“勾住”自定义组件中的“小写开头的类似原生标签的组件”？</h2> <p>答：使用React.forwardRef()。</p> <h5 id="你是否思考过这个问题-自定义组件到底是什么"><a href="#你是否思考过这个问题-自定义组件到底是什么" class="header-anchor">#</a> 你是否思考过这个问题：自定义组件到底是什么？</h5> <p>首先看一下“小写开头的类似原生标签的组件”，例如&lt;button&gt;、&lt;input &gt;，我们很容易理解他是react内置的类似原生DOM的组件，最终都将直接转换成对应的真实DOM。</p> <p>那自定义组件又该如何理解，如何定义呢？</p> <p>假设我们有一个自定义组件&lt;MyComponent&gt;，那么有以下几点是可以肯定的：<br>
1、&lt;MyComponent&gt;内部return出去的，可以是小写开头的类似原生标签的组件，也可以是其他自定义组件。<br>
2、无论嵌套多少次，最底层组件return出去的，一定是小写开头的类似原生标签的组件。<br>
3、&lt;MyComponent&gt;内部一定创建了变量、处理函数等等。<br>
4、挂载或渲染后的实际网页中，并不会存在&lt;MyComponent&gt;这个标签，存在的依然是各种原生html标签。</p> <p>为了简化更加容易理解，暂时姑且先把“小写开头的类似原生标签的组件”直接当做“原生html标签”。<br>
那么“自定义组件”和“原生html标签”究竟区别在哪里呢？</p> <p>先不回答这个问题，再说另外一个问题：交互式html页面都有哪些构成？<br>
答：有各种html标签 + JS对象(JS中定义的变量和函数)</p> <p>那我们使用react开发页面，“原生html标签”有了，那还缺什么？ 当然是 JS对象(JS中定义的变量和函数)。</p> <p>再回顾一下问题：“自定义组件”和“原生html标签”究竟区别在哪里呢？<br>
答：“自定义组件”除了拥有“原生html标签”，还拥有JS对象(JS中定义的变量和函数)。</p> <p>再回顾一下开始的疑问：自定义组件到底是什么？<br>
答：其实根本不存在自定义组件，所谓自定义组件，只不过是react给我们的各种语法糖，react并没有创造另外一门语言，react整体就是原生JS的语法糖。</p> <p>JSX语法 + Hook 组合起来，形成一个强大的语法糖，让你编写html标签和JS更加简便而已。
语法糖的对象就是：原生html标签 + JS对象(JS中定义的变量和函数)。</p> <p>这就解释了为啥自定义组件 return 出去的内容，最外层必须有一个原生html标签。 说白了，无论你怎么定义，折腾这个自定义组件，本质上都要保证这个自定义组件最终都能转换成一段原生html代码。</p> <p>上面这一大段话都是“简单到不能再简单的道理”，但是你只有理解透这一层，理解自定义组件、理解react究竟是什么之后，你会对于学习React各种API和Hook才会更加容易理解和接受。</p> <p>让我们回到 那如何“勾住”自定义组件中的“小写开头的类似原生标签的组件”？ 这个问题上来。</p> <h5 id="react-forwardref-的具体用法"><a href="#react-forwardref-的具体用法" class="header-anchor">#</a> React.forwardRef() 的具体用法</h5> <p>React.forwardRef()包裹住要输出的组件，且将第2个参数设置为 ref 即可，示例代码：</p> <div class="language- extra-class"><pre><code>import React from 'react'

const ChildComponent = React.forwardRef((props,ref) =&gt; {
  //子组件通过将第2个参数ref 添加到内部真正的“小写开头的类似原生标签的组件”中 
  return &lt;button ref={ref}&gt;{props.label}&lt;/button&gt;
});

/* 上面的子组件直接在父组件内定义了，如果子组件是单独的.js文件，则可以通过
   export default React.forwardRef(ChildComponent) 这种形式  */

function Forward() {
  const ref = React.useRef();//父组件定义一个ref
  const clickHandle = () =&gt;{
    console.log(ref.current);//父组件获得渲染后子组件中对应的DOM节点引用
  }
  return (
    &lt;div&gt;
        {/* 父组件通过给子组件添加属性 ref={ref} 将ref作为参数传递给子组件 */}
        &lt;ChildComponent label='child bt' ref={ref} /&gt;
        &lt;button onClick={clickHandle} &gt;get child bt ref&lt;/button&gt;
    &lt;/div&gt;
  )
}
export default Forward;
</code></pre></div><hr> <p>至此，关于useRef()基础用法、React.forwardRef()已经讲完。 这2个函数的掌握，会对下一个要讲的Hook：useImperativeHandle 非常有用。</p></div></div>  <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023-09-19, 09:20:46</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/8b008f/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">11 useMemo基础用法</div></a> <a href="/pages/ede426/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">13 useImperativeHandle基础用法</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/8b008f/" class="prev">11 useMemo基础用法</a></span> <span class="next"><a href="/pages/ede426/">13 useImperativeHandle基础用法</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:allen@183.co" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="//github.183.co" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://i.y.qq.com/n2/m/share/details/taoge.html?id=8424326180&amp;hosteuin=" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2023
    <span>Allen | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6f8ed848.js" defer></script><script src="/assets/js/2.83be7545.js" defer></script><script src="/assets/js/19.eab216d3.js" defer></script>
  </body>
</html>

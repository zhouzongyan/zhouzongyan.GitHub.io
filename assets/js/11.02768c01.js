(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{325:function(e,t,n){"use strict";n.r(t);var a=n(7),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_04-useeffect基础用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_04-useeffect基础用法"}},[e._v("#")]),e._v(" 04 useEffect基础用法")]),e._v(" "),t("h2",{attrs:{id:"useeffect概念解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useeffect概念解释"}},[e._v("#")]),e._v(" useEffect概念解释")]),e._v(" "),t("p",[e._v("我们第二个要学习的Hook(钩子函数)是useEffect，他的作用是“勾住”函数组件中某些生命周期函数。")]),e._v(" "),t("p",[e._v("都能勾住哪些生命周期函数？"),t("br"),e._v("\n答：componentDidMount(组件被挂载完成后)、componentDidUpdate(组件重新渲染完成后)、componentWillUnmount(组件即将被卸载前)")]),e._v(" "),t("p",[e._v("为什么是这3个生命周期函数？"),t("br"),e._v("\n答：因为修改数据我们可以使用前面学到的useState，数据变更会触发组件重新渲染，上面3个就是和组件渲染关联最紧密的生命周期函数。")]),e._v(" "),t("p",[e._v("那其他生命周期函数呢？"),t("br"),e._v("\n答：该问题的回答，引用"),t("a",{attrs:{href:"https://react.docschina.org/docs/hooks-faq.html#do-hooks-cover-all-use-cases-for-classes",target:"_blank",rel:"noopener noreferrer"}},[e._v("React官方中文文档FAQ"),t("OutboundLink")],1),e._v("，如下")]),e._v(" "),t("blockquote",[t("p",[e._v("我们给 Hook 设定的目标是尽早覆盖 class 的所有使用场景。目前暂时还没有对应不常用的 getSnapshotBeforeUpdate，getDerivedStateFromError 和 componentDidCatch 生命周期的 Hook 等价写法，但我们计划尽早把它们加进来。")])]),e._v(" "),t("h2",{attrs:{id:"useeffect是来解决类组件什么问题的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useeffect是来解决类组件什么问题的"}},[e._v("#")]),e._v(" useEffect是来解决类组件什么问题的？")]),e._v(" "),t("p",[e._v("答：useEffect是来解决类组件 "),t("strong",[e._v("某些执行代码被分散在不同的生命周期函数中")]),e._v(" 的问题。")]),e._v(" "),t("p",[e._v("举例1：若某类组件中有变量a，默认值为0，当组件第一次被挂载后或组件重新渲染后，将网页标题显示为a的值。"),t("br"),e._v("\n那么在类组件里，我们需要写的代码是：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//为了更加清楚看到每次渲染，我们在网页标题中 a 的后面再增加一个随机数字\ncomponentDidMount(){\n    document.title = `${this.state.a} - ${Math.floor(Math.random()*100)}`;\n}\ncomponentDidUpdate(){\n    document.title = `${this.state.a} - ${Math.floor(Math.random()*100)}`;\n}\n")])])]),t("p",[e._v("从上面这种代码里你会看到，为了保证第一次被挂载、组件重新渲染后都执行修改网页标题的行为，相同的代码我们需要分别在componentDidMount、componentDidUpdate中写2次。")]),e._v(" "),t("p",[e._v("举例2：假设需要给上面那个组件新增一个功能，当组件第一次被挂载后执行一个自动累加器 setInterval，每1秒 a 的值+1。为了防止内存泄露，我们在该组件即将被卸载前清除掉该累加器。"),t("br"),e._v("\n那么在类组件里，我们需要写的代码是：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("timer = null;//新增一个可内部访问的累加器变量(注：类组件定义属性时前面无法使用 var/let/const)\ncomponentDidMount(){\n    document.title = `${this.state.a} - ${Math.floor(Math.random()*100)}`;\n    this.timer = setInterval(() => {this.setState({a:this.state.a+1})}, 1000);//添加累加器\n}\ncomponentDidUpdate(){\n    document.title = `${this.state.a} - ${Math.floor(Math.random()*100)}`; \n}\ncomponentWillUnmount(){\n    clearInterval(this.timer);//清除累加器\n}\n")])])]),t("p",[e._v("从上面代码可以看到，增加累加器和清除累加器这2个相关的执行代码被分别定义在componentDidMount、componentWillUnmount这两个生命周期函数中。")]),e._v(" "),t("p",[e._v("举例3：假设给上面的组件再新增一个变量 b，当 b 的值发生变化后也会引发组件重新渲染，然后呢？有什么隐患吗？"),t("br"),e._v("\n答：b 的值改变引发组件重新渲染，然后肯定是会触发componentDidUpdate函数，这时会让修改网页标题的代码再次执行一次，尽管此时a的值并没有发生任何变化。")]),e._v(" "),t("p",[e._v("再来回顾一下上面的3个例子："),t("br"),e._v("\n1、举例1中，相同的代码可能需要在不同生命周期函数中写2次；"),t("br"),e._v("\n2、举例2中，相关的代码可能需要在不同生命周期函数中定义；"),t("br"),e._v("\n3、举例3中，无论是哪个原因引发的组件重新渲染，都会触发生命周期函数的执行，造成一些不必要的代码执行；")]),e._v(" "),t("p",[e._v("以上就是 类组件“某些执行代码被分散在不同的生命周期函数中”引发的问题具体表现，而useEffect就是来解决这些问题的。")]),e._v(" "),t("p",[e._v("接下来开始学习useState。")]),e._v(" "),t("h2",{attrs:{id:"useeffect函数源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useeffect函数源码"}},[e._v("#")]),e._v(" useEffect函数源码：")]),e._v(" "),t("p",[e._v("回到useEffect的学习中，首先看一下React源码中的"),t("a",{attrs:{href:"https://github.com/facebook/react/blob/master/packages/react/src/ReactHooks.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("ReactHooks.js"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//备注：源码采用TypeScript编写，如果不懂TS代码，阅读起来稍显困难\nexport function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n")])])]),t("p",[e._v("上述代码看不懂没关系，本系列教程只是讲述“如何使用Hook”，并不是“Hook源码分析”。之所以贴出源码只是为了让你以后也可以给面试官吹嘘你读过React源码。^_^")]),e._v(" "),t("h2",{attrs:{id:"useeffect基本用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useeffect基本用法"}},[e._v("#")]),e._v(" useEffect基本用法")]),e._v(" "),t("p",[e._v("useEffect(effect,[deps])函数可以传入2个参数，第1个参数为我们定义的执行函数、第2个参数是依赖关系(可选参数)。若一个函数组件中定义了多个useEffect，那么他们实际执行顺序是按照在代码中定义的先后顺序来执行的。")]),e._v(" "),t("p",[e._v("具体说明如下："),t("br"),e._v("\n第1个值effect是一个function，用来编写useEffect对应的执行代码。"),t("br"),e._v("\n还记得本文开头提到的useEffect能勾住哪3个生命周期函数吗？"),t("br"),e._v("\ncomponentDidMount、componentDidUpdate、componentWillUnmount ，当上述3个生命周期函数执行后，就会触发useEffect函数，进而执行而第1个参数 effect 中的内容。")]),e._v(" "),t("p",[e._v("组件挂载后(componentDidMount)与组件重新渲染后(componentDidUpdate)对应的代码合并为一个函数这个容易理解，可是组件卸载前(componentWillUnmount)也能融入进来？"),t("br"),e._v("\n答：是的，通过在 effect 中 return 一个函数来实现的。")]),e._v(" "),t("p",[e._v("关于第2个参数 [deps] ，先知道这个是可选参数，是Hook用来向React表明useEffect依赖关系的即可。关于它的用法会在useEffect高级用法中有更多详细讲述。")]),e._v(" "),t("h5",{attrs:{id:"代码形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码形式"}},[e._v("#")]),e._v(" 代码形式：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("useEffect(() => {\n    //此处编写 组件挂载之后和组件重新渲染之后执行的代码\n    ...\n\n    return () => {\n        //此处编写 组件即将被卸载前执行的代码\n        ...\n    }\n},[deps])\n")])])]),t("p",[e._v("之前说过useEffect第1个参数 effect 是个 function，只是这个 function 稍显复杂。")]),e._v(" "),t("h5",{attrs:{id:"拆解说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拆解说明"}},[e._v("#")]),e._v(" 拆解说明：")]),e._v(" "),t("p",[e._v("1、effect 函数主体内容中的代码，就是组件挂载之后和组件重新渲染之后你需要执行的代码；"),t("br"),e._v("\n2、effect 函数 return 出去的返回函数主体内容中的代码，就是组件即将被卸载前你需要执行的代码；"),t("br"),e._v("\n3、第2个参数 [deps]，为可选参数，若有值则向React表明该useEffect是依赖哪些变量发生改变而触发的；")]),e._v(" "),t("h4",{attrs:{id:"effect-补充说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#effect-补充说明"}},[e._v("#")]),e._v(" 'effect'补充说明")]),e._v(" "),t("p",[e._v("1、若你不需要在组件卸载前执行任何代码，那么可以忽略不写 effect 中的 return相关代码；")]),e._v(" "),t("h5",{attrs:{id:"deps-补充说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#deps-补充说明"}},[e._v("#")]),e._v(" '[deps]'补充说明：")]),e._v(" "),t("p",[e._v("1、若缺省，则组件挂载、组件重新渲染、组件即将被卸载前，每一次都会触发该useEffect；"),t("br"),e._v("\n3、若传值，则必须为数组，数组的内容是函数组件中通过useState自定义的变量或者是父组件传值过来的props中的变量，告诉React只有数组内的变量发生变化时才会触发useEffect；"),t("br"),e._v("\n4、若传值，但是传的是空数组 []，则表示该useEffect里的内容仅会在“挂载完成后和组件即将被卸载前”执行一次；")]),e._v(" "),t("h2",{attrs:{id:"useeffect使用示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useeffect使用示例"}},[e._v("#")]),e._v(" useEffect使用示例：")]),e._v(" "),t("p",[e._v("还记得本文上面关于 类组件“某些执行代码被分散在不同的生命周期函数中”引发的问题时，所举的3个例子吗？"),t("br"),e._v("\n我们用Hook来依次分别实现举例1、举例2、举例3，通过3个功能的代码示例，让你明白useEffect的具体用法。")]),e._v(" "),t("p",[e._v("举例1：若某类组件中有变量a，默认值为0，当组件第一次被挂载后或组件重新渲染后，将网页标题显示为a的值。"),t("br"),e._v("\n补充说明："),t("br"),e._v("\n1、为了让 a 的值可以发生变化，我们在组件中添加一个按钮，每次点击 a 的值 +1"),t("br"),e._v("\n2、为了更加清楚看到每次渲染，我们在网页标题中 a 的后面再增加一个随机数字")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import React, { useState,useEffect} from 'react';\n\nfunction Component() {\n  const [a, setA] = useState(0);//定义变量a，并且默认值为0\n  useEffect(() => {\n      //无论是第一次挂载还是以后每次组件更新，修改网页标题的执行代码只需要在这里写一次即可\n      document.title = `${a} - ${Math.floor(Math.random()*100)}`;\n  })\n  const clickAbtHandler = (eve) =>{\n      setA(a+1);\n  }\n  return <div>\n      {a}\n      <button onClick={clickAbtHandler}>a+1</button>\n    </div>\n}\n\nexport default Component;\n")])])]),t("p",[e._v("从上述代码可以看出，“类组件中相同的代码可能需要在不同生命周期函数中写2次”这个问题已通过Hook useEffect已解决。")]),e._v(" "),t("p",[e._v("这里只是实现列 举例1 中的功能，是useEffect最基础的用法。举例2、举例3 中的功能实现我们放到 useEffect 高级用法 中来讲解。")]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("至此，关于useEffect基础用法已经讲完。")])])}),[],!1,null,null,null);t.default=s.exports}}]);
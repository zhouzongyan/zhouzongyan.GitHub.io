<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Gorm中修改mysql主键的方法</title><url>/post/go/gorm%E4%B8%AD%E4%BF%AE%E6%94%B9mysql%E4%B8%BB%E9%94%AE%E7%9A%84%E6%96%B9%E6%B3%95/</url><categories><category>go</category></categories><tags><tag>go</tag><tag>gorm</tag></tags><content type="html"><![CDATA[  一、为什么要修改mysql主键策略1、我们创建mysql数据表的时候正常操作都是采用id自增类型,但是往往会造成以下几个问题 让别人可以猜到你数据库的数据量多少,甚至可以根据当前看到的id可以手动的修改浏览器上id来访问下一条数据 如果分表后会造成主键id是一样的 2、正常的做法可以修改mysql主键策略 直接使用uuid来作为主键,但是这样不好的地方是无序的,不会根据从前往后排列 使用雪花算法生成一个唯一的id
二、gorm中修改mysql表主键的方法1、直接使用数据表的hook方法,官网地址，直接在hook里面修改主键的值 2、使用gorm插件的方式全局修改,官网地址，官网上的案例似乎有点问题，自行验证
三、使用gorm插件来自定义主键1、选用的雪花算法第三方库,链接地址
2、创建一个plugin.go的文件，我也不废话，直接贴上我自己定义的代码
package common import ( &#34;fmt&#34; &#34;gin-admin-api/utils&#34; &#34;github.com/bwmarrin/snowflake&#34; &#34;gorm.io/gorm&#34; ) type DbFieldPlugin struct{} func (op *DbFieldPlugin) Name() string { return &#34;dbFieldPlugin&#34; } func (op *DbFieldPlugin) Initialize(db *gorm.DB) (err error) { // 创建字段的时候雪花算法生成id db.Callback().Create().Before(&#34;gorm:create&#34;).Replace(&#34;id&#34;, func(db *gorm.DB) { node, _ := snowflake.NewNode(1) id := node.Generate() db.Statement.SetColumn(&#34;id&#34;, fmt.Sprintf(&#34;%d&#34;, id)) accountId := db.Statement.Context.Value(&#34;accountId&#34;) //fmt.Println(accountId, &#34;????&#34;) db.Statement.SetColumn(&#34;created_by&#34;, accountId) }) // 创建人 db.Callback().Create().Before(&#34;gorm:create&#34;).Replace(&#34;created_by&#34;, func(db *gorm.DB) { if db.Statement.Schema != nil { fmt.Println(&#34;创建的钩子函数&#34;) // 获取到上下文中数据 accountId := db.Statement.Context.Value(&#34;accountId&#34;) fmt.Println(accountId, &#34;????&#34;) db.Statement.SetColumn(&#34;created_by&#34;, accountId) } }) // 更新人 db.Callback().Update().Before(&#34;gorm:before_update&#34;).Replace(&#34;updated_by&#34;, func(db *gorm.DB) { if db.Statement.Schema != nil { fmt.Println(&#34;修改&#34;) accountId := db.Statement.Context.Value(&#34;accountId&#34;) db.Statement.SetColumn(&#34;updated_by&#34;, accountId) } }) db.Callback().Update().Before(&#34;gorm:after_update&#34;).Replace(&#34;updated_by1&#34;, func(db *gorm.DB) { fmt.Println(&#34;更新后&#34;) fmt.Println(db.Statement.Model, &#34;当前数据11&#34;) fmt.Println(utils.MapToJson(db.Statement.Dest), &#34;当前数据21&#34;) }) // 删除人 db.Callback().Delete().Before(&#34;gorm:delete&#34;).Replace(&#34;deleted_by&#34;, func(db *gorm.DB) { if db.Statement.Schema != nil { accountId := db.Statement.Context.Value(&#34;accountId&#34;) fmt.Println(&#34;删除1111&#34;, accountId) db.Statement.SetColumn(&#34;deleted_by&#34;, accountId) } }) return } 3、使用插件
db.Use(&amp;DbFieldPlugin{})   ]]></content></entry><entry><title>Golang拉取Github私有库的姿势</title><url>/post/go/golang%E6%8B%89%E5%8F%96github%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E5%A7%BF%E5%8A%BF/</url><categories><category>go</category></categories><tags><tag>go</tag><tag>module</tag></tags><content type="html"><![CDATA[  我们的 Go 项目拉取依赖时,默认使用的是 https 协议的 git clone 。因此当你的 Golang 项目位于 Github 的私有仓库时,而你本地的项目又依赖这个私有库,此时你应当先设置SSH 保证 Git 能无密码拉取到该依赖
其次你还必须要设置 GOPRIVATE ,当你设置后, go get 命令在碰到该仓库时,将会不走 Go Proxy 从而进行直连。
示例:
go env -w GOPRIVATE=github.com/xhyonline 那么github.com/xhyonle 组织下的私有库在你使用 go get 命令时,都能被拉取下来,当然你一定需要设置 SSH 或者 Github Token(这两个选一个即可)
GOPRIVATE ，可以填写多个值，例如:
GOPRIVATE=*.corp.example.com,rsc.io/private GOPRIVATE=*.corp.example.com,rsc.io/private 这样 go 命令会把所有包含这个后缀的软件包，包括 git.corp.example.com/xyzzy , rsc.io/private, 和 rsc.io/private/quux 都以私有仓库来对待。
使用 Github Token,使用 Token 的好处在于你可以进行 CI 集成
如果你使用 Github Token 你需要自行进行 Token设置
示例如下:
git config --global url.&#34;https://$UserName :$Token@github.com&#34;.insteadOf &#34;https://github.com&#34; 其中 $UserName 是你的用户名(注:是用户名,而不是登录 github 的邮箱,我的就是xhyonline)
$Token 是你申请的 Token
申请 Token 地址如下:https://github.com/settings/tokens当你设置号成功之后你可以通过下面这条命令查看是否设置成功
git config --global --list 当然你也可以重新编辑,使用下面这条命令即可
git config --global --edit 当你使用 Github Action 进行 CI 操作时,你就可以使用 Github Token
.github/workflows/github-action.yml 配置文件如下
name: CI构建 on: push: branches: [ main,master ] pull_request: branches: [ main ,master ] # merge到main分支时触发部署 env: APP_NAME: myapp # 给 APP 起一个名字 jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: 检出代码 uses: actions/checkout@master - name: 设置环境 Golang 环境 uses: actions/setup-go@v2 with: go-version: 1.17 - name: 设置私有仓库和GoProxy run: | export GOPROXY=https://goproxy.io,direct # 如果你有 github 的私有库,请自行设置 GOPRIVATE 示例如下,注下面的 UserName 是用户名,例如:xhyonline,而不是你登录 Github 的邮箱 # git config --global url.&#34;https://${{ secret.UserName }}:${{secret.Token}}@github.com&#34;.insteadOf &#34;https://github.com&#34; # export GOPRIVATE=github.com/xhyonline - name: CI-lint 代码质量检测 uses: golangci/golangci-lint-action@v2 with: # Optional: version of golangci-lint to use in form of v1.2 or v1.2.3 or `latest` to use the latest version version: v1.29 - name: 构建 BuiLd run: | go build -o app - name: upx 压缩二进制文件 uses: crazy-max/ghaction-upx@v1 with: version: latest files: | app args: -fq - name: 同步文件 uses: burnett01/rsync-deployments@5.1 with: switches: -avzr --delete path: ./app remote_path: /micro-server/$APP_NAME # 发布到远程主机,当然你需要自己创建 /micro-server 目录 $APP_NAME 是全局的变量 remote_host: ${{ secrets.Host }} remote_port: 22 remote_user: root remote_key: ${{ secrets.DeploySecret }} # 请使用 ssh-keygen -t rsa 生成秘钥对,然后将公钥拷贝到要操纵的目标器的/root/.ssh/authorized_keys里,再把私钥黏贴到 github 后台的secret里 - name: 执行重启命令 uses: appleboy/ssh-action@master with: host: ${{ secrets.Host }} username: root key: ${{ secrets.DeploySecret }} port: 22 script: | # 请自行在这里执行应用的重启命令,这里我没重启,只是查看了下构建的结果 pwd ls /micro-server - name: 构建结果通知 uses: zzzze/webhook-trigger@master if: always() # 失败成功总会发送 with: data: &#34;{&#39;event_type&#39;:&#39;build-result&#39;,&#39;status&#39;:&#39;${{ job.status }}&#39;, &#39;repository&#39;:&#39;${{ github.repository }}&#39;,&#39;job&#39;:&#39;${{ github.job }}&#39;, &#39;workflow&#39;:&#39;${{ github.workflow }}&#39;}&#34; webhook_url: ${{ secrets.WebHookURL }} options: &#34;-H \&#34;Accept: application/vnd.github.everest-preview+json\&#34; -H \&#34;Authorization: token ${{ secrets.TOKEN }}\&#34;&#34; 相关资料如下:
http://www.phpxs.com/post/7108/?ivk_sa=1024320uhttps://gist.github.com/Kovrinic/ea5e7123ab5c97d451804ea222ecd78a  ]]></content></entry><entry><title>Windows下配置多个git账号的ssh</title><url>/post/git/windows%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgit%E8%B4%A6%E5%8F%B7%E7%9A%84ssh/</url><categories><category>Git</category></categories><tags><tag>ssh</tag><tag>git</tag></tags><content type="html"><![CDATA[  由于笔者使用多个git网站，所以需要配置多个ssh，以下我们来配置多个ssh。
生成密钥 已经有一个密钥的情况下，用下面的命令生成一个新密钥，注意为了防止原始密钥文件被覆盖，需要给一个新名字：
ssh-keygen -t rsa -f C:\\Users\\xxx\\.ssh\\id_rsa_xxx -C &#34;xxx@email.com&#34; 给GitHub配置SSH Key 去setting里找到SSH添加.pub文件的内容。
测试 使用如下命令测试ssh能不能用：
ssh -T git@github.com -i C:\\Users\\xxx\\.ssh\\id_rsa_xxx 配置config文件 在.ssh文件夹下添加config文件，内容里添加：
Host SomethingYouLike HostName github.com IdentityFile C:\\Users\\xxx\\.ssh\\id_rsa_xxx PreferredAuthentications publickey 这个配置文件的参数含义如下：
Host # 主机别名 HostName # 服务器真实地址 IdentityFile # 私钥文件路径 PreferredAuthentications # 认证方式 User # 用户名 重新测试 ssh -T git@SomethingYouLike
设置GitHub仓库的远程连接方式 首先更新仓库的用户名和邮箱，使其变成新账号的：
git config user.name &#34;username&#34; git config user.email &#34;username@email.com&#34; 接着重新建立连接。如果之前仓库已经设置过了就用以下命令先删掉原来的连接：
git remote rm origin 然后再更改添加新的远程连接：
git remote add origin git@SomethingYouLike:YourGitHubName/xxx.git   ]]></content></entry><entry><title>Npm私有仓库搭建——Verdaccio</title><url>/post/node/npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BAverdaccio/</url><categories><category>Node</category></categories><tags><tag>verdaccio</tag><tag>npm</tag></tags><content type="html"> 众所周知，每家公司都有可能需要发布自己的私有仓库，所以要将包发布到内网而不是发布到npm的公共注册表，以下使用**verdaccio**，搭建一个简单的私有npm仓库。
安装Verdaccio: 首先，你需要在你的机器上安装**verdaccio**。你可以通过npm来安装它：
npm install -g verdaccio 运行Verdaccio: 一旦安装完毕，你可以运行**verdaccio**来启动你的私有注册表服务器：
verdaccio --listen 192.168.0.8:4873 默认情况下，它将在**http://localhost:4873**上运行。
添加用户（可选）: 如果你想要保护你的私有注册表，你可以添加一个用户并设置密码：
npm adduser --registry http://localhost:4873 登录用户 npm login --registry http://localhost:4873/ 发布包: 现在你可以发布你的包到你的私有注册表。确保你在项目的**package.json文件中指定了正确的name和version**，然后运行以下命令：
npm publish --registry http://localhost:4873 你的包现在应该已经发布到你的私有注册表，并可以通过该注册表进行安装。
安装包: 要从你的私有注册表安装包，你可以运行以下命令：
npm install your-package-name --registry http://localhost:4873 更新最新的包
npm install [package-name]@latest --registry http://localhost:4873</content></entry><entry><title>WeRead2Notion Pro使用文档</title><url>/post/tool/weread2notion-pro%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url><categories><category><no value=/></categories><tags><tag><no value=/><tag><no value=/></tags><content type="html"><![CDATA[  WeRead2Notion-Pro使用文档
预览效果使用Weread2Notion和Weread2Notion-Pro是两个不同的项目，模板也不相同，切勿用错模板。
Weread2Notion教程：https://malinkang.com/posts/weread2notion/热力图使用教程：https://malinkang.com/posts/github_heatmap/Fork工程打开Weread2Notion-Pro，点击右上角的Fork（顺便点个star谢谢）
权限确保你打开了读写权限。
依次选择Settings-&amp;gt;Actions-&amp;gt;General，然后下拉，找到Workflow permissions，如果没有选中Read and write permissions，请选中，然后点下面的save保存。
获取微信读书Cookie浏览器打开网页版微信读书扫码登录 按F12进入开发者模式，依次点网络-&amp;gt;文档，然后选中weread.qq.com，下拉找到Cookie，复制Cookie值 如果没有内容显示，请刷新下浏览器。
建议使用Chrome浏览器，有的小伙伴使用QQ浏览器拿到的Cookie一直不能用。
获取NotionToken浏览器打开https://www.notion.so/my-integrations点击New integration按钮，输入name后点Submit。 提交完成后，进入Secrets页面，先点击Show，然后点击Copy复制，后面需要用到 复制Notion模板浏览器打开模板https://malinkang.notion.site/13d2e1548f024687a42ec68a79a01c62?pvs=4，点击右上角的Duplicate复制。 打开你刚复制的模板，点击右上角的三个点，找到Connections，然后添加你创建的Integration。 点击右上角的Share，然后点击Copy link获取页面的链接。 这里是通过数据库的名字来自动获取对应的ID的，所以请先不要修改数据库的名字。在Github的Secrets中添加变量打开你fork的工程，点击Settings-&amp;gt;Secrets and variables-&amp;gt;New repository …  ]]></content></entry><entry><title>基于GithubAction自动构建Hugo博客</title><url>/post/tool/%E5%9F%BA%E4%BA%8Egithubaction%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/</url><categories><category>博客</category></categories><tags><tag>gihub</tag><tag>blog</tag></tags><content type="html"> 本文主要记录了如何配置 Github Action 实现 Hugo 博客自动部署。
GitHub Actions 快速入门
hugo quick-start
#1. 概述 Hugo 都是静态博客，即最终生成的是静态页面，而所谓部署就是把这些静态文件放到 web 服务器(比如 Nginx、Caddy) 的对应目录就行了。
因此整个 Github Action 只需要做两件事：
1）编译，生成静态文件 2）部署，把静态文件移动到合适的位置 比如放到某个云服务器上 或者放到 Github Pages 然后我们再通过 git push 来触发 Github Action 就可以了。
#2. 具体实现 添加 Github Action 需要在仓库根目录下创建 .github/workflow 这个二级目录，然后在 workflow 下以 yml 形式配置 Github Action。
具体可以参考 这个仓库
需要指定 action 触发条件，这里就设置为 push 触发，具体如下：
on: push: branches: - main # Set a branch to deploy pull_request: 以上表示在 main分支收到 push 事件时执行该 action。
如果是之前创建的仓库，可能需要改成 master 分支。
另外我们可以直接在 marketplace
找别人配置好的 action 来使用，就更加方便了，以下是本教程用到的 action
actions/checkout
hugo-setup
github-pages-action
rsync
我们要做的就是把这些单独的 action 进行组合，以实现自动部署。
发布到 Github Pages 静态博客可以直接用 Github Pages，比较简单，缺点就是国内访问会比较慢，甚至于直接打不开。
action 文件如下
name: GitHub Pages
on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - …</content></entry><entry><title>Hugo博客引入Giscus评论系统</title><url>/post/tool/hugo%E5%8D%9A%E5%AE%A2%E5%BC%95%E5%85%A5giscus%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url><categories><category><no value=/></categories><tags><tag><no value=/><tag><no value=/></tags><content type="html"> Hugo博客引入Giscus评论系统
1. 选择一个评论系统
当前使用的 hugo 生成静态博客，主题是 LoveIt。该主题已经支持了多种评论系统：
disqus gitalk valine facebook telegram giscus …. 有很多，其中 giscus 是基于 Github Discussions 的，我们的博客也是放在 Github 的，那么为了简单起见就选择 giscus 吧。 ##什么是 gitcus？ Giscus 是由 GitHub Discussions 驱动的评论系统，根据官网，Giscus的特性有：
开源。 无跟踪，无广告，永久免费。 无需数据库。全部数据均储存在 GitHub Discussions 中。 支持自定义主题！ 支持多种语言。 高度可配置。 自动从 GitHub 拉取新评论与编辑。 可自建服务！ ##原理 Giscus 使用 GitHub Discussions 作为数据库存储博客下面的评论。
Giscus 插件加载时，会使用 GitHub Discussions 搜索 API 根据选定的映射方式（如 URL、pathname、 等）来查找与当前页面关联的 discussion。如果找不到匹配的 discussion，giscus bot 就会在第一次有人留下评论或回应时自动创建一个 discussion。
要评论，访客必须按 GitHub OAuth 流程授权 giscus app 代表他发帖。或者访客也可以直接在 GitHub Discussion 里评论，作者可以在 GitHub 上管理评论。 #2. 引入 giscus 由于主题已经支持 gitcus 评论了，因此引入其实是比较简单的，大致分为以下几个步骤：
0）选择一个仓库作为存储 Discussions 的仓库
一般选择博客本身即可，比如这里我用的就是这个 zhouzongyan/zhouzongyan.github.io ##1）安装 giscus
将 giscus 安装到上一步指定的仓库，这样 giscus 才有权限获取数据 ##2）开启 GitHub Discussions
将上面选择的仓库开启 GitHub Discussions 用于存放评论 ##3）从 giscus 官网获取配置信息
##4）将上一步中获取的配置添加到博客配置
###1. …</content></entry><entry><title>Giscus的基础设置</title><url>/post/tool/giscus%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE/</url><categories><category><no value=/></categories><tags><tag><no value=/><tag><no value=/></tags><content type="html"><![CDATA[  Giscus的基础设置
不过这两项评论系统与我目前搭建博客的理念是相悖的。一来是这两个系统没有让我获得所有的评论数据，二来是这两个系统让评论者也默认了他们的评论数据被交由这两个公司处理。随后了解到一些Gitment、Gitalk等一些基于GitHub Issues设计的评论系统。显然这些基于GitHub Issues的评论系统更符合我现在的理念。最后刚好也是因为目前这个博客主题Chirpy的更新，我也决定加入一个评论系统到博客里面。毕竟没有评论系统的博客感觉更像是一个对于作者本人的笔记本，少了一些可以讨论的部分。
新的Chirpy 5.0主题内置了三个评论系统的支持，分别是Disqus、Utterance和Giscus。这里选择了最年轻的Giscus作为评论系统。相关的配置在_config.yml下可以看到如下的配置：
giscus: repo: # &lt;gh-username&gt;/&lt;repo&gt; repo_id: category: category_id: mapping: # optional, default to &#39;pathname&#39; input_position: # optional, default to &#39;bottom&#39; lang: # optional, default to the value of `site.lang` 很显然其中三项并没有给出太详细的信息，在查询了多个帖子后，我确定了三项的对应的数据。在这里记录一下查询的方法。
首先，repo_id是托管博客的代码仓库的一个标识值，category是该仓库Issues里面对应的分类（或者说是主题）。一个仓库默认具有下面几个分类：Announcements、General、Ideas、Q&amp;A、Show and tell。这里我选择General作为评论的分类。最后的category_id类似repo_id也是对该分类的一个标识值。
如何快速的获取这些数据呢，可以通过GitHub官方的GraphQL API Explorer查询到。这里把查询所用的语句进行记录。
{ repository(owner: &#34;MichaelTan9999&#34;, name: &#34;michaeltan9999.github.io&#34;) { id discussionCategories (first: 5) { nodes { name id } } } } 点击查询后，我们会得到如下结果：
{ &#34;data&#34;: { &#34;repository&#34;: { &#34;id&#34;: &#34;R_kgDOG6UKFQ&#34;, &#34;discussionCategories&#34;: { &#34;nodes&#34;: [ { &#34;name&#34;: &#34;Announcements&#34;, &#34;id&#34;: &#34;DIC_kwDOG6UKFc4CBXaW&#34; }, { &#34;name&#34;: &#34;General&#34;, &#34;id&#34;: &#34;DIC_kwDOG6UKFc4CBXaX&#34; }, { &#34;name&#34;: &#34;Ideas&#34;, &#34;id&#34;: &#34;DIC_kwDOG6UKFc4CBXaZ&#34; }, { &#34;name&#34;: &#34;Q&amp;A&#34;, &#34;id&#34;: &#34;DIC_kwDOG6UKFc4CBXaY&#34; }, { &#34;name&#34;: &#34;Show and tell&#34;, &#34;id&#34;: &#34;DIC_kwDOG6UKFc4CBXaa&#34; } ] } } } } 我们将对应的ID填到_config.yml就大功告成了。
别忘了在GitHub个人设置里面的Integrations中安装Giscus并授权
  ]]></content></entry><entry><title>无服务器自建短链服务Url Shorten Worker完整的部署教程</title><url>/post/tool/%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%BB%BA%E7%9F%AD%E9%93%BE%E6%9C%8D%E5%8A%A1url-shorten-worker%E5%AE%8C%E6%95%B4%E7%9A%84%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/</url><categories><category><no value=/></categories><tags><tag><no value=/><tag><no value=/></tags><content type="html"> 无服务器自建短链服务Url-Shorten-Worker完整的部署教程
源码 GitHub: https://github.com/crazypeace/Url-Shorten-Worker
申请Cloudflare账号，略。
创建一个KV
记得这个KV的名字，以 urlsrv 为例
查看此KV
添加一个条目Entry
密钥key为password，值value为一个随机字符串.
* password这个key是在脚本中要引用的，所以要设置这个。
随机字符串可以使用http://git.io/xkcdpw生成
随机字符串以 yejiandianci 为例
创建Worker服务
设置绑定KV
变量名称必须设置为 LINKS， KV
的名字选刚刚创建的 urlsrv
* LINKS 是在脚本中要引用的，所以要设置这个。换句话说，如果你使用别的脚本，可能这个变量名称就不是
LINKS
了。
编辑Worker的脚本
把原有的内容全部删掉
换成：https://github.com/crazypeace/Url-Shorten-Worker/blob/main/worker.js 的内容
保存并部署
======
如果要当网络记事本 PasteBin
如果要当图床 Image Hosting
如果要当网络日记本, 支持MarkDown
======
完
要访问 你的worker域名/yejiandianci 来打开使用页面
如：https://snowy-disk-fd82.ciys.workers.dev/yejiandianci
======
后记
你可以通过
在你自己的域名下worker页面添加一个路由指向worker
的方式来实现比如 https://1way.eu.org/mtSzm6
替代 snowy-disk-fd82.ciys.workers.dev/yejiandianci 的效果。
======
开发记录
直接访问域名返回404。在KV中设置一个entry，保存秘密path，只有访问这个path才显示使用页面。
https://zelikk.blogspot.com/2022/07/url-shorten-worker-hide-tutorial.html
支持自定义短链
https://zelikk.blogspot.com/2022/07/url-shorten-worker-custom.html
API 不公开服务
https://zelikk.blogspot.com/2022/07/url-shorten-worker-api-password.html
页面缓存设置过的短链
https://zelikk.blogspot.com/2022/08/url-shorten-worker-localstorage.html
长链接文本框预搜索localStorage
https://zelikk.blogspot.com/2022/08/url-shorten-worker-bootstrap-list-group-oninput.html
增加删除某条短链的按钮
https://zelikk.blogspot.com/2022/08/url-shorten-worker-delete-kv-localstorage.html
访问计数功能 可查询短链 成为功能完整的短链API系统
https://zelikk.blogspot.com/2023/11/url-shorten-worker-visit-count-api-api.html
阅后即焚功能, 可制作一次性二维码
https://zelikk.blogspot.com/2023/11/url-shorten-worker-snapchat-mode.html
增加读取 KV 中全部记录的功能
https://zelikk.blogspot.com/2024/01/url-shorten-worker-load-cloudflare-kv.html
变身网络记事本 Pastebin
https://zelikk.blogspot.com/2024/01/url-shorten-worker-pastebin.html
变身图床 Image Hosting
https://zelikk.blogspot.com/2024/01/url-shorten-worker-image-hosting-base64.html
变身日记本 NetJournal 支持Markdown
https://zelikk.blogspot.com/2024/02/url-shorten-worker-netjournal.html
https://zelikk.blogspot.com/2024/02/url-shorten-worker-netjournal-markdown.html</content></entry><entry><title>解决 Rust Tauri 1.0 构建时下载 WiX失败</title><url>/post/rust/01.%E8%A7%A3%E5%86%B3-rust-tauri-1.0-%E6%9E%84%E5%BB%BA%E6%97%B6%E4%B8%8B%E8%BD%BD-wix%E5%A4%B1%E8%B4%A5/</url><categories><category>rust</category></categories><tags/><content type="html"><![CDATA[  Windows 的安装器 WiX 的下载失败上：
外层的代理对命令行又不生效，最好的方式是把这个 WiX 包在浏览器下载完，然后放在 Tauri 需要的地方，让它直接使用，避免再在命令行里下载。
Tauri 的判断代码在这里：https://github.com/tauri-apps/tauri/blob/dev/tooling/bundler/src/bundle/windows/msi.rs#L29
/// Runs all of the commands to build the MSI installer. /// Returns a vector of PathBuf that shows where the MSI was created. pub fn bundle_project(settings: &amp;Settings, updater: bool) -&gt; crate::Result&lt;Vec&lt;PathBuf&gt;&gt; { let mut wix_path = dirs_next::cache_dir().unwrap(); wix_path.push(&#34;tauri/WixTools&#34;); if !wix_path.exists() { wix::get_and_extract_wix(&amp;wix_path)?; } else if WIX_REQUIRED_FILES .iter() .any(|p| !wix_path.join(p).exists()) { warn!(&#34;WixTools directory is missing some files. Recreating it.&#34;); std::fs::remove_dir_all(&amp;wix_path)?; wix::get_and_extract_wix(&amp;wix_path)?; } wix::build_wix_app_installer(settings, &amp;wix_path, updater) } dirs_next::cache_dir() 的结果如下：
Platform Value Example Linux $XDG_CACHE_HOME or $HOME/.cache /home/alice/.cache macOS $HOME/Library/Caches /Users/Alice/Library/Caches Windows {FOLDERID_LocalAppData} C:\Users\Alice\AppData\Local 所以直接把 Wix 下载完后，在 C:\Users\xxxxxxxx\AppData\Loca 中，创建 tauri/WixTools 文件夹，然后把内容解压到里面就可以了。
正常构建完成：
  ]]></content></entry><entry><title>21 React扩展阅读</title><url>/post/react/21.react%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/</url><categories><category>react</category></categories><tags/><content type="html"> React扩展阅读
Youtube中Codevolution专栏下的React Hooks Tutorial系列视频
链接：
https://pan.baidu.com/s/1Lj_kN-FuO5bbZ2rqMVz6xw
提取码：70ni
自定义 Hook 大全
必不可少的 React Hooks集合。
https://github.com/zenghongtu/react-use-chinese
React技术揭秘
卡颂写的 React 源码分析。
https://react.iamkasong.com/
阿里 ahooks 工具库
蚂蚁umi团队、淘系ice团队、阿里体育共同建设的 React Hooks 工具库
https://ahooks.js.org/zh-CN
网易云音乐前端团队 React Hooks 最佳实践
实际项目中总结出的 React Hooks 实用经验
https://mp.weixin.qq.com/s/HwlnvAh18saKwXC_nZwSHw
React 300问
React 300多道面试题和答案
https://github.com/semlinker/reactjs-interview-questions
阿里推出的React框架：antd
antd 4.0版本全部采用函数组件开发而成。
https://ant.design/docs/react/introduce-cn
京东推出的多端统一开发框架：taro
Taro是一套遵循React语法规范的多端开发解决方案。
https://taro-docs.jd.com/taro/
学习React的几个好的微信公众号
React中文社区、不知非攻、魔术师卡颂</content></entry><entry><title>20 React基础知识</title><url>/post/react/20.react%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  React基础知识说明：以下这些基础知识适用于类组件和函数组件，并不是函数组件独有的。
安装react并初始化1、安装：npm install -g create-react-app2、创建hello-react目录并初始化：npx create-react-app hello-react注意：
目录名不允许有大写字母 初始化过程比较慢，甚至可能需要5-10分钟 如果报错：npm ERR! Unexpected end of JSON input while parsing near &amp;lsquo;&amp;hellip;n\r\nwsFcBAEBCAAQBQJd&amp;rsquo;， 解决方法：npm root -g 找到本机npm全局安装目录，cd 进入该目录，执行清除缓存：npm cache clean &amp;ndash;force，然后再次初始化。 3、启动项目：cd hello-react、npm start默认将启动：http://localhost:3000
自定义组件基础知识1、自定义组件必须以大写字母开头、默认网页原生标签还以小写开头。请注意这里表述的&amp;quot;默认网页原生标签&amp;quot;本质上并不是真实的原生网页标签，他们是react默认定义好的、内置的自定义组件标签，只不过这些标签刚好和原生标签的作用，功能，名称一模一样而已。
2、自定义组件如果不希望设定最外层的标签，那么可以使用react(16+版本)提供的占位符Fragment来充当最外层标签；
import React,{Component,Fragment} from &#39;react&#39;; 类组件：render(){return &amp;lt;Fragment&amp;gt;xxxxxxx&amp;lt;/Fragment&amp;gt;} 函数组件：return &amp;lt;Fragment&amp;gt;xxxxxxx&amp;lt;/Fragment&amp;gt;在最新的react版本中，也可以直接使用&amp;lt;&amp;gt;&amp;lt;/&amp;gt;来代替Fragment。其中&amp;lt;&amp;gt;唯一可以拥有的属性为key。即&amp;lt; key=&amp;lsquo;xxx&amp;rsquo;&amp;gt;&amp;lt;/&amp;gt;
3、使用数组map循环更新li，一定要给li添加对应的key值，否则虽然正常运行，但是会报错误警告。不建议直接使用index作为key值。
4、在最新 …  ]]></content></entry><entry><title>19 useTransition基础用法</title><url>/post/react/19.usetransition%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  19 useTransition基础用法useTransition概念介绍react提供了useDeferredValue发挥类似防抖节流的作用，而useTransition也是类似的作用，但是该hook是通过降低数据渲染的优先级来达到优先更新其他数据
useTransition用来解决什么问题？首先给定一个场景，开发时经常会遇到需要联想输入，也就是输入的同时要返回联想搜索结果的列表。 但是这个列表有时返回值非常的长，有时会导致用户输入值的更新缓慢，这里就产生了一个问题，当页面有大量UI更新的时候，怎么处理数据更新不会卡顿。 可以手写防抖节流，防抖有一个弊端，当我们长时间的持续输入（时间间隔小于防抖设置的时间），页面就会长时间都不到响应。而startTransition 可以指定 UI 的渲染优先级，哪些需要实时更新，哪些需要延迟更新。即使用户长时间输入最迟 5s 也会更新一次。 也可以用useDeferredValue，也可以用“可视窗口加载”的方案， 在这里介绍怎么用useTransition解决 useTransition源码回到useTransition的学习中，首先看一下React源码中的ReactHooks.js。
export function useTransition(): [ boolean, (callback: () =&amp;gt; void, options?: StartTransitionOptions) =&amp;gt; void, ] { const dispatcher = resolveDispatcher(); return dispatcher.useTransition(); } 再根据引入文件，到react-reconciler/src/ReactInternalTypes.js找到Dispatch里最终调用的useTransition
useTransition(): [ boolean, (callback: () =&amp;gt; void, options?: StartTransitionOptions) =&amp;gt; void, ], 上述代码看不懂没关系，本系列教程只是讲述“如何使用Hook”，并不是“Hook源码分析”。^_^
useTransition基本用法useTransition()函数可以不传参，传 …  ]]></content></entry><entry><title>18 示例：React使用Echarts所用到的hooks</title><url>/post/react/18.%E7%A4%BA%E4%BE%8Breact%E4%BD%BF%E7%94%A8echarts%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84hooks/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  18 示例：React使用Echarts所用到的hooks本篇文章写于 2020年11月13日，距离前面文章已经过去半年，因此本文的讲述风格和示例代码，可能和前面的章节不同。
Echarts简介Echarts 是百度公司推出的，基于原生 JS 的图表库，免费开源 ，可用于数据可视化项目。
官网地址：https://echarts.apache.org/zh/feature.html
Echarts基础操作1、Echarts 是基于原生 JS 的库，而不是 React 组件，需要将 “图表” 挂载到 DOM
2、echarts.init(xxx-dom) 是创建 “图表” 的入口函数，该函数将创建创建真正的图表实例，并填充到 xxx-dom 中
3、一个图表 对应一个 DOM，N 个图标需要 N 个 DOM
4、图表实例通过 setOption(option) 来设置(更新)数据
针对以上Echarts特性，对应的 hooks1、使用 useRef 来勾住 jsx 中的某个 DOM
2、使用 useEffect( () =&gt; {}, [] ) 来勾住 React 第一次挂载，并通过 echarts.init(xxx-dom) 创建出真正的图表
3、使用 useState 来勾住 创建出的真正图表，以便以后做各种更新操作
4、使用 useEffect( () =&gt; {}, [xxx-echart,option] ) 来不断监听组件传递过来的数据变化，并更新图表数据
补充说明：尽管 NPM 中已经有 echarts-for-react 这个包，已经将 Echarts 封装成可直接使用的 React 组件，但是我并不是建议使用，因为毕竟 Echarts 并不是特别难，没有必要使用别人封装好的。学习本文后，你自己也可以轻松封装自己的 Echarts 组件，灵活方便。
使用(封装)Echarts示例代码细节不过多说，此处只演示 2 个组件源码，使用 TypeScript 编写
子组件为一个图表，图表是什么类型，由 配置数据 option 中 xAxis.type 的值决定 父组件负责调用子组件并传递图表配置数据 父组件：
import React from &#39;react&#39; import { EChartOption } from &#39;echarts&#39; import Echart from &#39;../../components/echart&#39; import &#39;./index.scss&#39; const option: EChartOption = { xAxis: { type: &#39;category&#39;, data: [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;] }, yAxis: { type: &#39;value&#39; }, series: [{ data: [820, 932, 901, 934, 1290, 1330, 1320], type: &#39;line&#39; }] } const IndexPage: React.FC = () =&gt; { return ( &lt;Echart option={option} /&gt; ) } export default IndexPage 子组件：
import React, { useState, useRef, useEffect } from &#39;react&#39; import echarts, { EChartOption, ECharts } from &#39;echarts&#39; import &#39;./index.scss&#39; interface EchartProp { option: EChartOption } const Echart: React.FC&lt;EchartProp&gt; = ({ option }) =&gt; { const chartRef = useRef&lt;HTMLDivElement&gt;(null) //用来勾住渲染后的 DOM const [echartsInstance, setEchartsInstance] = useState&lt;ECharts&gt;() //用来勾住生成后的 图表实例对象 //仅第一次挂载时执行，将 DOM 传递给 echarts，通过 echarts.init() 得到真正的图表 JS 对象 useEffect(() =&gt; { if (chartRef.current) { setEchartsInstance(echarts.init(chartRef.current)) } }, []) //监听依赖变化，并根据需要更新图表数据 useEffect(() =&gt; { echartsInstance?.setOption(option) }, [echartsInstance, option]) return ( &lt;div ref={chartRef} className=&#39;echarts&#39; /&gt; ) } export default Echart 以上示例中，父组件功能相对简单，负责调用子组件，并将图表配置数据传递给子组件。
真正需要关注的就是 子组件，在子组件中分别用到了 useRef、useState、useEffect 这 3 个 hook，尤其是 useEffect 还被使用了 2 次。
  ]]></content></entry><entry><title>17 React Hook 总结</title><url>/post/react/17.react-hook-%E6%80%BB%E7%BB%93/</url><categories><category>react</category></categories><tags/><content type="html"> 17 React Hook 总结
首先，对你能够坚持到现在，表示深深的赞扬，学习React Hook之路不容易。
我们快速的回顾一下之前学习过的各个hook。
react hook 回顾
定义变量
useState()
：定义普通变量
useReducer()
：定义有不同类型、参数的变量
组件传值
useContext()
：定义和接收具有全局性质的属性传值对象，必须配合React.createContext()使用
对象引用
useRef()
：获取渲染后的DOM元素对象，可调用该对象原生html的方法，可能需要配合React.forwardRef()使用
useImperativeHandle()
：获取和调用渲染后的DOM元素对象拥有的自定义方法，必须配合React.forwardRef()使用
生命周期
useEffect()
：挂载或渲染完成后、即将被卸载前，调度
useLayoutEffect()
：挂载或渲染完成后，同步调度
性能优化
useCallback()
：获取某处理函数的引用，必须配合React.memo()使用
useMemo()
：获取某处理函数返回值的副本
代码调试
useDebugValue()
：对react开发调试工具中的自定义hook，增加额外显示信息
自定义hook
useCustomHook()
：将hook相关逻辑代码从组件中抽离，提高hook代码可复用性
react hook 扩展阅读
附01：React基础知识
附02：React扩展阅读
信息反馈
若有错误欢迎指正，本人QQ (1933668022)，或通过邮件联系：allen@183.co
至此，React Hook 你已学习完成。
真心为你鼓掌，加油，在实践中去提升自己的 React Hook 战斗值吧。</content></entry><entry><title>16 自定义hook</title><url>/post/react/16.%E8%87%AA%E5%AE%9A%E4%B9%89hook/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  16 自定义hook自定义hook概念解释像useState、useEffect、useContext、useReducer、useCallback、useMemo、useRef、useImperativeHandle、useLayoutEffect、useDebugValue这10个hook是react默认自带的hook，而所谓自定义hook就是由我们自己编写的hook。
所谓自定义hook就是把原来写在函数组件内的hook相关代码抽离出来，单独定义成一个函数，而这个抽离出来的hook函数就称之为“自定义hook钩子函数”，简称“自定义hook”。
自定义hook是来解决什么问题的？答：自定义hook是将原来在组件中编写的相关hook代码抽离出组件，让hook相关代码独立存在，达到优化代码结构、相关hook代码可以重复使用的目的。
补充说明：
1、如果你在别人的项目代码中，发现除了react默认自带的那10个hook以外，出现了 useXxx() 这样的看着像hook的函数，可以肯定那些就是自定义的hook。
2、随着react新版本发布，可能会出现更多新的、默认自带的hook。
自定义hook基本用法首先我们知道hook只能用在函数组件中，而函数组件本身是一个稍微特殊的函数，尽管稍微特殊但毕竟他也遵循一般函数的使用规律。 所谓“把原来写在函数组件内的hook相关代码抽离出来，单独定义成一个函数” 本质上就是把函数内部定义的变量或方法拿出来，放到函数外面单独定义成一个函数。
这个抽离出来新定义的函数，遵循JS默认的函数用法，即函数参数可以任意设定，返回值也可以是任意内容。
请注意：react规定所有的自定义hook函数命名时必须使用 useXxx 这种形式。
举一个最简单的例子：假设我们有一个组件，组件内部有一个count的变量，我们的代码之前是这样的：
import React,{useState} from &#39;react&#39;function CurrentComponent() {const [count,setCount] = useState(0);//请注意这行代码，就是我们要即将抽离出去的hookreturn (&amp;lt;div&amp;gt;{count}&amp;lt;button onClick={() =&amp;gt; …  ]]></content></entry><entry><title>15 useDebugValue基础用法</title><url>/post/react/15.usedebugvalue%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"> 15 useDebugValue基础用法
useDebugValue概念解释
我们第十个要学习的Hook(钩子函数)是useDebugValue，他的作用是“勾住”React开发调试工具中的自定义hook标签，让useDebugValue勾住的自定义hook可以显示额外的信息。
“React开发调试工具”是什么？
答：谷歌浏览器中的一个扩展插件，名字叫“React Developer Tools”，方便我们在谷歌浏览器上进行react项目调试。
如何安装？
答：可在Chrome扩展程序商店搜索并安装。由于国内网络原因，如果你不会科学上网，那么可以通过国内的一些Chrome扩展程序商店网站，下载“React Developer Tools”离线的crx安装文件进行安装。具体办法可以自己百度。
“React开发调试工具”的使用简单说明：
如果该扩展程序安装成功，那么会有以下几种情况：
1、对于本机开发调试的项目网页，该插件图标会变成橘黄色，且图标中间有一个小虫子，表示可以进行react源码式的调试，当代码出现错误时会精准定位出错的代码位置。
2、对于别人开发的项目网页，该插件图标会变成蓝色，表示该网页由react开发，当代码出现错误时不能精准定位出错的代码位置。
例如阿里云后台、腾讯云后台、百度翻译这些网页都是用react开发，访问这些网页你就会看到 调试工具图光标为蓝色。 这些大厂都用react，所以虽然学习过程中很痛苦，但是是值得的。
3、对于没有使用react的网页，该插件图标会变成灰色。
让我们回到useDebugValue基础学习中。
useDebugValue是来解决什么问题的？
答：useDebugValue的目的是“在react开发者工具自定义hook标签中显示额外信息”，方便我们“一眼就能找到”对应的自定义hook。
补充说明：
1、react官网文档中明确表示，在普通项目开发中不推荐使用useDebugValue，默认的调试输出已经很清晰可用了。
2、除非你的自定义 hook 是作为共享库中的一部分才有价值。这样其他人更容易注意到你自定义的hook状态变化。
自定义hook？
你可能注意到本章中提到了“自定义hook”，没错。像之前学习的useState、useContext等等都是react自带的hook，这些默认的hook是我们项目开发所需要用到 …</content></entry><entry><title>14 useLayoutEffect基础用法</title><url>/post/react/14.uselayouteffect%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"> 14 useLayoutEffect基础用法
useLayoutEffect概念解释
我们第九个要学习的Hook(钩子函数)是useLayoutEffect，他的作用是“勾住”挂载或重新渲染完成这2个组件生命周期函数。useLayoutEffect使用方法、所传参数和useEffect完全相同。
他们的不同点在于，你可以把useLayoutEffect等同于componentDidMount、componentDidUpdate，因为他们调用阶段是相同的。而useEffect是在componentDidMount、componentDidUpdate调用之后才会触发的。
也就是说，当组件所有DOM都渲染完成后，同步调用useLayoutEffect，然后再调用useEffect。
useLayoutEffect永远要比useEffect先触发完成。
那通常在useLayoutEffect阶段我们可以做什么呢？
答：在触发useLayoutEffect阶段时，页面全部DOM已经渲染完成，此时可以获取当前页面所有信息，包括页面显示布局等，你可以根据需求修改调整页面。
请注意，useLayoutEffect对页面的某些修改调整可能会触发组件重新渲染。如果是对DOM进行一些样式调整是不会触发重新渲染的，这点和useEffect是相同的。
在react官方文档中，明确表示只有在useEffect不能满足你组件需求的情况下，才应该考虑使用useLayoutEffect。 官方推荐优先使用useEffect。
请注意：如果是服务器渲染，无论useEffect还是useLayoutEffect 都无法在JS代码加载完成之前执行，因此都会收到错误警告。 服务器渲染时若想使用useEffect，解决方案不在本章中讨论。
让我们回到useLayoutEffect基础学习中。
useLayoutEffect是来解决什么问题的？
答：useLayoutEffect的作用是“当页面挂载或渲染完成时，再给你一次机会对页面进行修改”。
如果你选择使用useLayoutEffect，对页面进行了修改，更改样式不会引发重新渲染，但是修改变量则会触发再次渲染。
如果你不使用useLayoutEffect，那么之后就应该调用useEffect。
补充说明：
1、优先使 …</content></entry><entry><title>13 useImperativeHandle基础用法</title><url>/post/react/13.useimperativehandle%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"> 13 useImperativeHandle基础用法
useImperativeHandle概念解释
我们第八个要学习的Hook(钩子函数)是useImperativeHandle，他的作用是“勾住”子组件中某些函数(方法)供父组件调用。
先回顾一下之前学到的。
第1个知识点：
react属于单向数据流，父组件可以通过属性传值，将父组件内的函数(方法)传递给子组件，实现子组件调用父组件内函数的目的。
第2个知识点： 1、useRef 可以“勾住”某些本组件挂载完成或重新渲染完成后才拥有的某些对象。
2、React.forwardRef 可以“勾住”某些子组件挂载完成或重新渲染完成后才拥有的某些对象。
上面无论哪种情况，由于勾住的对象都是渲染后的原生html对象，父组件只能通过ref调用该原生html对象的函数(方法)。
如果父组件想调用子组件中自定义的方法，该怎么办？
答：使用useImperativeHandle()。
让我们回到useImperativeHandle基础学习中。
useImperativeHandle是来解决什么问题的？
答：useImperativeHandle可以让父组件获取并执行子组件内某些自定义函数(方法)。本质上其实是子组件将自己内部的函数(方法)通过useImperativeHandle添加到父组件中useRef定义的对象中。
补充说明：
1、useRef创建引用变量
2、React.forwardRef将引用变量传递给子组件
3、useImperativeHandle将子组件内定义的函数作为属性，添加到父组件中的ref对象上。
因此，如果想使用useImperativeHandle，那么还要结合useRef、React.forwardRef一起使用。
useImperativeHandle函数源码：
回到useImperativeHandle的学习中，首先看一下React源码中的
ReactHooks.js
。
//备注：源码采用TypeScript编写，如果不懂TS代码，阅读起来稍显困难
export function useImperativeHandle&amp;amp;lt;T&amp;amp;gt;(
ref: {|current: T | null|} | ((inst: T | null) =&amp;amp;gt; mixed) | null | void, …</content></entry><entry><title>12 useRef基础用法</title><url>/post/react/12.useref%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  12 useRef基础用法useRef概念解释我们第七个要学习的Hook(钩子函数)是useRef，他的作用是“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象，并返回该对象的引用。该引用在组件整个生命周期中都固定不变，该引用并不会随着组件重新渲染而失效。
上面这段话，就算你认真读几遍，估计也是一头雾水，到底说的是啥？
我也实在想不出其他更加通俗的语言来描述useRef，不过经过下面的详细分解描述，相信能帮到你来理解useRef。
“某些组件挂载完成或重新渲染完成后才拥有的某些对象”：这句话中的“某些对象”主要分为3种：JSX组件转换后对应的真实DOM对象、在useEffect中创建的变量、子组件内自定义的函数(方法)。
第1：JSX组件转换后对应的真实DOM对象：
举例：假设在JSX中，有一个输入框&amp;lt;input type=&amp;lsquo;text&amp;rsquo; /&amp;gt;，这个标签最终将编译转换成真正的html标签中的&amp;lt;input type=&amp;lsquo;text&amp;rsquo;/&amp;gt;。
你应该知道以下几点：
1、JSX中小写开头的组件看似和原生html标签相似，但是并不是真的原生标签，依然是react内置组件。
2、什么时候转换？ 虚拟DOM转化为真实DOM
3、什么时候可访问？组件挂载完成或重新渲染完成后
对于上面举例中的那个转换后的&amp;lt;input/&amp;gt; 真实DOM，只有组件挂载完成或重新渲染完成后才可以访问，它就就属于“某些组件挂载完成或重新渲染完成后才拥有的某些对象”。
特别强调：useRef只适合“勾住”小写开头的类似原生标签的组件。如果是自定义的react组件(自定义的组件必须大写字母开头)，那么是无法使用useRef的。
思考：如何获取这个 &amp;lt;input/&amp;gt; 真实DOM呢？
答：用useRef。
第2：在useEffect中创建的变量：
举例，请看以下代码：
useEffect(() =&amp;gt; {let timer = setInterval(() =&amp;gt; {setCount(prevData =&amp;gt; prevData +1);}, 1000);return () =&amp;gt; {clearInterval(timer);}},[]);上述代码中，请注意这个timer是 …  ]]></content></entry><entry><title>11 useMemo基础用法</title><url>/post/react/11.usememo%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"> 11 useMemo基础用法
useMemo概念解释
我们第六个要学习的Hook(钩子函数)是useMemo，他的作用是“勾住”组件中某些处理函数的返回值，创建这些返回值对应在react原型链上的索引。当组件重新渲染时，需要再次用到这些函数返回值，此时不再重新执行一遍运算，而是直接使用之前运算过的返回值。useMemo第2个参数是处理函数的变量依赖，只有当处理函数依赖的变量发生改变时才会重新计算并保存一次函数返回结果。
假设你已经对React.memo，useCallback的运行机制充分了解，那么对你而言useMemo的用法非常好理解。
useCallback是将某个函数“放入到react底层原型链上，并返回该函数的索引”，而useMemo是将某个函数返回值“放入到react底层原型链上，并返回该返回值的索引”。一个是针对函数，一个是针对函数返回值。
网上有些人的文章里，会提到：useCallback(fn, deps) 相当于 useMemo(() =&amp;amp;gt; fn, deps)。
这句话似乎是没有问题，但是他隐藏或者说忽略了几个重要关键点：
1、不是所有fn(函数)都适用的，必须是该函数有返回值，即函数有 return xx 才可以。
2、虽然都是fn，但是函数体内代码内容却相差很大，useCallback中的fn主要用来处理各种操作事务的代码，例如修改某变量值或加载数据等。而useMemo中的fn主要用来处理各种计算事务的代码。
3、useCallback和useMemo都是为了提升组件性能，但是他们两个的适用场景却不相同，不是谁是谁的替代品或谁是谁的简化版。
再次强调一遍，useCallback中的函数是侧重“操作事务”，useMemo中的函数是侧重“计算结果”，永远不要在useMemo的函数中添加修改数据之类的代码。
让我们回到useMemo基础学习中。
useMemo是来解决什么问题的？
答：useMemo的目的是“减少组件重新渲染时不必要的函数计算”。
useMemo可以将某些函数的计算结果(返回值)挂载到react底层原型链上，并返回该函数返回值的索引。当组件重新渲染时，如果useMemo依赖的数据变量未发生变化，那么直接使用原型链上保存的该函数计算结果，跳过本次无意义的重新计算，达到提高组件性能的目的。
补充说明：
1、useMemo并不需要子组 …</content></entry><entry><title>10 useCallback基础用法</title><url>/post/react/10.usecallback%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"> 10 useCallback基础用法
useCallback概念解释
我们第五个要学习的Hook(钩子函数)是useCallback，他的作用是“勾住”组件属性中某些处理函数，创建这些函数对应在react原型链上的变量引用。useCallback第2个参数是处理函数中的依赖变量，只有当依赖变量发生改变时才会重新修改并创建新的一份处理函数。
react原型链？
我对react原型链也不太懂，你可以简单得把 react原型链 理解成 “react定义的一块内存”。我们使用某些 hook 定义的“变量或函数”都存放在这块内存里。这块内存里保存的变量或函数，并不会因为组件重新渲染而消失。
1、当我们需要使用时可以“对象的引用名”从该内存里获取，例如useContext
2、当希望更改某些变量时，可以通过特定的函数来修改该内存中变量的值，例如useState中的setXxxx()
3、当某些函数依赖变量发生改变时，react可以重新生成、并修改该内存中对应的函数，例如useReducer、useCallback
此处更新与2020年10月13日
今天学习了一下 JS 原型链：每一个对象或者说由 function 创建的对象，他们都有一个属性 __proto__，该属性值为创建该对象的构造函数的原型对象，又称 隐式原型，而这一层的隐式原型也有 __proto__ 属性，即 __proto__.__proto__ 属性值为 Object.prototype，还可以继续再往下深入 __proto__.__proto__.__proto__为了避免死循环，最终到此，即 Object.prototype.__proto__ 为 null。作为构造函数对象，有属性 prototype，属性值为该函数的显示原型对象。constructor 则表示原型对象的构造函数本身。
const arr = [1, 2, 3] console.log(arr.__proto__ === Array.prototype) // true console.log(arr.__proto__.__proto__ === Object.prototype) // true console.log(Object.prototype.__proto__ === null) // true function …</content></entry><entry><title>09 useReducer高级用法</title><url>/post/react/09.usereducer%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  09 useReducer高级用法所谓高级用法，只不过是一些深层知识点和实用技巧，你甚至可以把本章当做对前面知识点的一个巩固和学习。
使用useReducer来管理复杂类型的数据举例，若某组件内通过ajax请求数据，获取最新一条站内短信文字，需要组件显示整个ajax过程及结果：
1、当ajax开始请求时，界面显示“loading&amp;hellip;”；
2、当ajax请求发生错误时，界面显示“wrong!”;
3、当ajax请求成功获取数据时，界面显示获取到的数据内容；
如果我们使用useState来实现上述功能，伪代码如下：
function Component() {const [loading,setLoading] = useState(true); //是否ajax请求中，默认为trueconst [result,setResult] = useState(&#39;&#39;); //请求数据内容，默认为&#39;&#39;const [error,setError] = useState(false); //请求是否发生错误，默认为false{//ajax请求成功setLoading(false);setResult(&#39;You have a good news!&#39;);//请注意，这是一行伪代码，只是为了演示，并不是真正ajax获取的结果setError(false);//ajax请求错误setLoading(false);setError(true);}return &amp;lt;div&amp;gt;{loading ? &#39;loading...&#39; : result}{error ? &#39;wrong!&#39; : null}&amp;lt;/div&amp;gt;}如果我们使用useReducer来实现，则可将上述3个变量都放在我们定义的变量state中，伪代码如下：
const initralData = {loading: true,result: &#39;&#39;,error: false};const reducer = (state, action) =&amp;gt; {switch (action.type) {case &#39;succes&#39;:return {loading:false,result:action.res,error:false}case &#39;error&#39;:return …  ]]></content></entry><entry><title>08 useReducer基础用法</title><url>/post/react/08.usereducer%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  08 useReducer基础用法useReducer概念解释我们第四个要学习的Hook(钩子函数)是useReducer，他的作用是“勾住”某些自定义数据对应的dispatch所引发的数据更改事件。useReducer可以替代useState，实现更为复杂逻辑的数据修改。
在React 16.8版本以前，通常需要使用第三方Redux来管理React的公共数据，但自从 React Hook 概念出现以后，可以使用 useContext + useReducer 轻松实现 Redux 相似功能。这一部分会在 “useReducer高级用法” 中做详细讲解。
让我们回到useReducer基础学习中。
useReducer是来解决什么问题的？答：useReducer是useState的升级版(实际上应该是原始版)，可以实现复杂逻辑修改，而不是像useState那样只是直接赋值修改。
补充说明：
1、在React源码中，实际上useState就是由useReducer实现的，所以useReducer准确来说是useState的原始版。
2、无论哪一个Hook函数，本质上都是通过事件驱动来实现视图层更新的。
useReducer函数源码：回到useReducer的学习中，首先看一下React源码中的ReactHooks.js。
//备注：源码采用TypeScript编写，如果不懂TS代码，阅读起来稍显困难export function useReducer&amp;lt;S, I, A&amp;gt;(reducer: (S, A) =&amp;gt; S,initialArg: I,init?: I =&amp;gt; S,): [S, Dispatch&amp;lt;A&amp;gt;] {const dispatcher = resolveDispatcher();return dispatcher.useReducer(reducer, initialArg, init);}上述代码看不懂没关系，本系列教程只是讲述“如何使用Hook”，并不是“Hook源码分析”。之所以贴出源码只是想让你重点看一下useReducer函数的第3个参数。一般我们只传2个参数，如果有一天你看到有人为了某些不常用的目的传了3个参数，你应该理解，第3个参数其实只是第1和第2个参数的某种转化。事实上你可以完全忽 …  ]]></content></entry><entry><title>07 useContext高级用法</title><url>/post/react/07.usecontext%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  07 useContext高级用法所谓高级用法，只不过是一些深层知识点和实用技巧，你甚至可以把本章当做对前面知识点的一个巩固和学习。
同时传递多个共享数据值给1个子组件实现以下组件需求：
1、有2个共享数据对象 UserContext、NewsContext；
2、父组件为AppComponent、子组件为ChildComponent；
3、父组件需要同时将UserContext、NewsContext的数据同时传递给子组件；
实现代码：
import React,{ useContext } from &#39;react&#39; const UserContext = React.createContext(); const NewsContext = React.createContext(); function AppComponent() { return ( &lt;UserContext.Provider value={{name:&#39;puxiao&#39;}}&gt; &lt;NewsContext.Provider value={{title:&#39;Hello React Hook.&#39;}}&gt; &lt;ChildComponent /&gt; &lt;/NewsContext.Provider&gt; &lt;/UserContext.Provider&gt; ) } function ChildComponent(){ const user = useContext(UserContext); const news = useContext(NewsContext); return &lt;div&gt; {user.name} - {news.title} &lt;/div&gt; } export default AppComponent; 代码分析：
1、父组件同时要实现传递2个共享数据对象value值，需要使用&lt;XxxContext.Provider value={obj}&gt;标签进行2次嵌套。
2、子组件使用了useContext，他可以自由随意使用父组件传递过来的共享数据value，并不需要多次嵌套获取。
同时将1个共享数据值传递给多个子组件使用&lt;XxxContext.Provider&gt;&lt;/XxxContext.Provider&gt;标签将多个子组件包裹起来，即可实现。
&lt;XxxContext.Provider value={{name:&#39;puxiao&#39;}}&gt; &lt;ComponentA /&gt; &lt;ComponentB /&gt; &lt;ComponentC /&gt; &lt;/XxxContext.Provider&gt; 3个子组件&lt;ComponentA /&gt;、&lt;ComponentB /&gt;、&lt;ComponentC /&gt;都可使用useContext获取共享数据值。
为什么不使用Redux？在Hook出现以前，React主要负责视图层的渲染，并不负责组件数据状态管理，所以才有了第三方Redux模块，专门来负责React的数据管理。
但是自从有了Hook后，使用React Hook 进行函数组件开发，实现数据状态管理变得切实可行。只要根据实际项目需求，使用useContext以及下一章节要学习的useReducer，一定程度上是可以满足常见需求的。
毕竟使用Redux会增大项目复杂度，此外还要花费学习Redux成本。
具体需求具体分析，不必过分追求Redux。
至此，关于useContext高级用法已经讲完，useContext降低了组件之间数据传递的复杂性，让我们编写代码更加心情愉悦，而不用去关心层层嵌套问题。
接下来学习第4个Hook函数useReducer。
  ]]></content></entry><entry><title>06 useContext基础用法</title><url>/post/react/06.usecontext%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  06 useContext基础用法useContext概念解释我们第三个要学习的Hook(钩子函数)是useContext，他的作用是“勾住”获取由React.createContext()创建、&amp;lt;XxxContext.Provider&amp;gt;添加设置的共享数据value值。useContext可以替代&amp;lt;XxxContext.Consumer&amp;gt;标签，简化获取共享数据的代码。
我们知道，原本不同级别的组件之间传递属性值，必须逐层传递，即使中间层的组件不需要这些数据。
注意：这里说的组件指React所有组件，包含类组件和函数组件。
数据层层传递增加了组件的复杂性，降低了可复用性。为了解决这个问题，我们可以使用以下方式：
1、在组件顶层或单独的模块中，由React.createContext()创建一个共享数据对象；
2、在父组件中添加共享数据对象的引用，通过且只能通过&amp;lt;XxxContext.provider value={xx:&#39;xxx&#39;}&amp;gt;&amp;lt;/XxxContext.provider&amp;gt;的形式将数据传递给子组件。请注意传值必须使用value={obj}这种形式，若值本身为字符串则可以改为 value=&amp;lsquo;xxx&amp;rsquo;；
3、若下一层的子组件用不到共享数据对象中的数据，则可以不做任何属性标签传递；
4、若某一层的子组件需要用到共享数据对象的数据，则可通过&amp;lt;XxxContext.Consumer&amp;gt;&amp;lt;/XxxContext.Consumer&amp;gt;获取到数据；
5、在类组件中除了&amp;lt;XxxContext.Consumer&amp;gt;标签，还有另外一种获取共享数据方式：static xxx = XxxContext; 但是这种形式在函数组件中无法使用。
简而言之&amp;lt;XxxContext.Provider&amp;gt;用来添加共享数据、&amp;lt;XxxContext.Consumer&amp;gt;用来获取共享数据。
备注：provider单词本意为供应者、consumer单词本意为消费者，刚好对应他们相对于共享数据的关系。
上面简单描述了React.createContext()的用法，由于本系列文章主要讲Hook的使用方法，React本身的知识点并不是重点讲解对象。若你 …  ]]></content></entry><entry><title>05 useEffect高级用法</title><url>/post/react/05.useeffect%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  05 useEffect高级用法所谓高级用法，只不过是一些深层知识点和实用技巧，你甚至可以把本章当做对前面知识点的一个巩固和学习。
让useEffect只在挂载后和卸载前执行一次让我们实现 “04 useEffect基础用法” 中 举例2 提到的功能。
组件需求：
1、若某类组件中有变量a，默认值为0，当组件第一次被挂载后或组件重新渲染后，将网页标题显示为a的值。
2、当组件第一次被挂载后执行一个自动累加器 setInterval，每1秒 a 的值+1。为了防止内存泄露，我们在该组件即将被卸载前清除掉该累加器。
需求分析：
关于自动累加器的操作，只关联 “组件挂载后和组件卸载前” 这2个生命周期函数中，那useEffect还包含了每次组件重新渲染后，这该怎么办？
答：useEffect函数的第2个参数表示该依赖关系，将useEffect的第2个参数，设置为空数组 []，即表示告诉React，这个useEffect不依赖任何变量的更新所引发的组件重新渲染，以后此组件再更新也不需要调用此useEffect。
这样就可以实现只在第一次挂载后和卸载前调用此useEffect的目的。
import React, { useState,useEffect} from &#39;react&#39;;function Component() {const [a, setA] = useState(0);//定义变量a，并且默认值为0//定义第1个useEffect，专门用来处理自动累加器useEffect(() =&amp;gt; {let timer = setInterval(() =&amp;gt; {setA(a+1)},1000);// &amp;lt;-- 请注意这行代码，暗藏玄机return () =&amp;gt; {clearInterval(timer);}}, []);//此处第2个参数为[]，告知React以后该组件任何更新引发的重新渲染都与此useEffect无关//定义第2个useEffect，专门用来处理网页标题更新useEffect(() =&amp;gt; {document.title = `${a} - ${Math.floor(Math.random()*100)}`;},[a])return &amp;lt;div&amp;gt; {a} &amp;lt;/div&amp;gt;} …  ]]></content></entry><entry><title>04 useEffect基础用法</title><url>/post/react/04.useeffect%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"> 04 useEffect基础用法
useEffect概念解释
我们第二个要学习的Hook(钩子函数)是useEffect，他的作用是“勾住”函数组件中某些生命周期函数。
都能勾住哪些生命周期函数？
答：componentDidMount(组件被挂载完成后)、componentDidUpdate(组件重新渲染完成后)、componentWillUnmount(组件即将被卸载前)
为什么是这3个生命周期函数？
答：因为修改数据我们可以使用前面学到的useState，数据变更会触发组件重新渲染，上面3个就是和组件渲染关联最紧密的生命周期函数。
那其他生命周期函数呢？
答：该问题的回答，引用
React官方中文文档FAQ
，如下
我们给 Hook 设定的目标是尽早覆盖 class 的所有使用场景。目前暂时还没有对应不常用的 getSnapshotBeforeUpdate，getDerivedStateFromError 和 componentDidCatch 生命周期的 Hook 等价写法，但我们计划尽早把它们加进来。
useEffect是来解决类组件什么问题的？
答：useEffect是来解决类组件 某些执行代码被分散在不同的生命周期函数中 的问题。
举例1：若某类组件中有变量a，默认值为0，当组件第一次被挂载后或组件重新渲染后，将网页标题显示为a的值。
那么在类组件里，我们需要写的代码是：
//为了更加清楚看到每次渲染，我们在网页标题中 a 的后面再增加一个随机数字
componentDidMount(){
document.title = `${this.state.a} - ${Math.floor(Math.random()*100)}`;
}
componentDidUpdate(){
document.title = `${this.state.a} - ${Math.floor(Math.random()*100)}`;
}
从上面这种代码里你会看到，为了保证第一次被挂载、组件重新渲染后都执行修改网页标题的行为，相同的代码我们需要分别在componentDidMount、componentDidUpdate中写2次。
举例2：假设需要给上面那个组件新增一个功能，当组件第一次被挂载后执行一个自动累加器 setInterval，每1秒 a 的值+1。为了防止内存 …</content></entry><entry><title>03 useState高级用法</title><url>/post/react/03.usestate%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  03 useState高级用法所谓高级用法，只不过是一些深层知识点和实用技巧，你甚至可以把本章当做对前面知识点的一个巩固和学习。
恢复默认值组件需求：实现一个计数器，有3个按钮，点击后分别实现：恢复默认值、点击+1、点击-1
实现代码：
import React, { useState } from &amp;#39;react&amp;#39;; function Component() { const initCount = 0; const [count, setCount] = useState(initCount); return &amp;lt;div&amp;gt; {count} &amp;lt;button onClick={() =&amp;gt; {setCount(initCount)}}&amp;gt;init&amp;lt;/button&amp;gt; &amp;lt;button onClick={() =&amp;gt; {setCount(count+1)}}&amp;gt;+1&amp;lt;/button&amp;gt; &amp;lt;button onClick={() =&amp;gt; {setCount(count-1)}}&amp;gt;-1&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; } export default Component; 代码分析：
1、通过额外定义一个变量initCount=0，作为count的默认值；
2、任何时候想恢复默认值，直接将initCount赋值给count；
解决数据异步还是基于上面那个示例，假设现在新增1个按钮，点击该按钮后执行以下代码：
for(let i=0; i&amp;lt;3; i++){setCount(count+1);}通过for循环，执行了3次setCount(count+1)，那么你觉得count会 +3 吗？
答案是：肯定不会
无论for循环执行几次，最终实际结果都将是仅仅执行一次 +1。
为什么？
类组件中setState赋值过程是异步的，同样在Hook中 setXxx 赋值也是异步的，比如上述代码中的setCount。
虽然执行了3次setCount(count+1)，可是每一次修改后的count并不是立即生效的。当第2次和第3次执行时获取到count的值和第1次获取到的count值是一样的，所以最终其实相当于仅执行了1次。
解决办法：你肯定第一时间想到的是这样解决方 …  ]]></content></entry><entry><title>02 useState基础用法</title><url>/post/react/02.usestate%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url><categories><category>react</category></categories><tags/><content type="html"><![CDATA[  02 useState基础用法useState概念解释我们第一个要学习的Hook(钩子函数)是useState，他的作用是“勾住”函数组件中自定义的变量。
“勾住”？
回顾一下 “React Hook 简介” 文中那句话：Hook本身单词意思是“钩子”，作用就是“勾住某些生命周期函数或某些数据状态，并进行某些关联触发调用”。
“如何勾住”？ 在React底层代码中，是通过自定义dispatcher，采用“发布订阅模式”实现的。
关于“钩子”、“勾住”、“如何勾住”的概念以后在学习其他Hook函数时不再做解释。
useState是来解决类组件什么问题的？答：useState能够解决类组件 所有自定义变量只能存储在this.state 的问题。
举例：若某组件需要有2个自定义变量name和age，那么在类组件中只能如下定义
constructor(props) {super(props);this.state = {name:&#39;puxiao&#39;,age:34}}name和age只能作为this.state的一个属性。
没有对比就没有伤害，看一下使用useState后，函数组件是如何实现上述需求的
const [name,setName] = useState(&#39;puxiao&#39;);const [age,setAge] = useState(34);1、函数组件本身是一个函数，不是类，因此没有构造函数constructor(props)；
2、任何你想定义的变量都可以单独拆分出去，独立定义，互不影响；
两段代码对比之下，你就会发现使用Hook的useState后，会让我们定义的变量相对独立，清晰简单，便于管理。
接下来开始学习useState。
useState函数源码：首先看一下React源码中的ReactHooks.js。
//备注：源码采用TypeScript编写，如果不懂TS代码，阅读起来稍显困难export function useState&amp;lt;S&amp;gt;(initialState: (() =&amp;gt; S) | S,): [S, Dispatch&amp;lt;BasicStateAction&amp;lt;S&amp;gt;&amp;gt;] {const dispatcher = resolveDispatcher();return …  ]]></content></entry><entry><title>React Hook 简介</title><url>/post/react/01.react-hook-%E7%AE%80%E4%BB%8B/</url><categories><category>react</category></categories><tags><tag><no value=/><tag><no value=/></tags><content type="html"> 01 React Hook 简介
首先，欢迎你来学习React Hook，通过本教程你会了解到React Hook工作原理以及我们推荐使用Hook的理由。
学习前提
在学习本课程之前，需要你对以下知识点有基础的了解：
1、React基础原理；
2、函数组件(Functional components)和类组件(class components)，属性传参(props)，自定义内部数据(state)，生命周期函数等；
3、使用谷歌浏览器且安装了“React Developer Tools”调试工具。
本系列文章适合有一定React开发基础的人，若是React新手，建议先从阅读React官方中文文档学起。
接下来正式开始本教程。
什么是Hooks？
Hook是React 16.8版本中新增的一个新特性，丰富扩展了原有函数组件的功能，让函数组件拥有了像类组件一样的相似特性。
在之前版本中函数组件不能使用React生命周期函数，Hook本身单词意思是“钩子”，作用就是“勾住某些生命周期函数或某些数据状态，并进行某些关联触发调用”。
不同的Hook(钩子)有不同的作用，可以勾住不同的“点”，比如“勾住组件更新完成对应的生命周期函数”、“勾住某props值的变化”等。
正因为React有多个内置Hook，所以本小节的标题才是“什么是Hooks？”，没错，用到了Hook的复数单词Hooks。
特别提醒：在React官网中使用的是Hook，而在有些教程中使用的是Hooks。在本教程中Hook和Hooks是同一个意思，不要纠结什么时候用单数什么时候是复数。
请注意：
1、尽管函数组件拥有了类组件多大多数的相似特性，但有一点除外：函数组件中没有类组件中“自定义state”的特性，因此你无法在函数组件中使用“this.state.xx”这样的代码。
没有不代表功能的缺失，恰恰相反，因为当你充分了解Hooks之后，你会发现函数组件内部自定义数据状态功能远远超出类组件。
2、Hooks只能运行在函数组件中，不能运行在类组件中。
补充：准确来说，Hooks只能运行在函数组件的“内部顶层中”，不能运行在if/for等其他函数的代码体内，不允许被if/for等包裹住。
3、Hooks函数必须为纯函数，所谓纯函数就是函数内部不能修改可能影响执行结果的任意参数，确保每次执行的代码结果都是一样的。
为什 …</content></entry><entry><title>windows系统中VS code未识别nodejs cmdlet错误</title><url>/post/go/02.windows%E7%B3%BB%E7%BB%9F%E4%B8%ADvs-code%E6%9C%AA%E8%AF%86%E5%88%ABnodejs-cmdlet%E9%94%99%E8%AF%AF/</url><categories><category>go</category></categories><tags/><content type="html"> 报错
最近笔者在windows使用VS code开发的时候，遇到一个奇怪的问题，在调试代码的过程中，发现通过代码执行VS code的命令命令终端时，始终无法正常运行，一直报cmdlet错误，但是通过自己手动打开命令终端执行命令却一切正常。错误如下图所示： 处理
经过查询资料发现，是由于windows权限问题，导致对应的脚本执行在代码打开的终端没有权限，直接就报错了，最开始由于编码问题看不到对应的错误信息，一直查询各种资料、代码断点，都没有发现问题，最后退出VS code，重新以管理员权限打开VS code再执行程序就解决了。</content></entry><entry><title>Go 配置 VS code 启动</title><url>/post/go/01.go-%E9%85%8D%E7%BD%AE-vs-code-%E5%90%AF%E5%8A%A8/</url><categories><category>go</category></categories><tags/><content type="html"><![CDATA[  最近笔者在学习gokins过程中，最开始的时候，使用goland编译运行，但是后面由于免费试用天数用完就无法使用了，经过比较，还是决定使用VS code运行，但是VS code默认是不支持运行，需要自己手动配置
1、安装go插件2、安装debug插件输入快捷键Ctrl + Shift + P打开命令快捷输入框，输入go install,选择下图的选项 然后下一个选择框选择dlv 的debug组件（这边建议全选，避免后面使用到对应的工具又要再装一遍），点击OK就可以开始安装了，安装过程中由于是下载国外资源，会比较慢和失败，建议多试几次，如果实在不行的话，就使用手动安装的方式，安装方式请参考dlv的github库指南3、配置启动文件ctrl+shift+p 输入 Debug: Open launch.json 打开 launch.json 文件，如果第一次打开,会新建一个配置文件，默认配置内容如下：
{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &#34;version&#34;: &#34;0.2.0&#34;, &#34;configurations&#34;: [ { &#34;name&#34;: &#34;Launch&#34;, &#34;type&#34;: &#34;go&#34;, &#34;request&#34;: &#34;launch&#34;, &#34;mode&#34;: &#34;auto&#34;, &#34;program&#34;: &#34;${fileDirname}&#34;, &#34;env&#34;: {}, &#34;args&#34;: [] } ] } 常用的属性如下所示：
属性 介绍 name 调试界面下拉选择项的名称 type 设置为go无需改动，是 vs code 用于计算调试代码需要用哪个扩展 mode 可以设置为 auto, debug, remote, test, exec 中的一个 program 调试程序的路径（绝对路径） env 调试时使用的环境变量。例如:{ &ldquo;ENVNAME&rdquo;: &ldquo;ENVVALUE&rdquo; } envFile 包含环境变量文件的绝对路径，在 env 中设置的属性会覆盖 envFile 中的配置 args 传给正在调试程序命令行参数数组 showLog 布尔值，是否将调试信息输出 logOutput 配置调试输出的组件（debugger, gdbwire, lldbout, debuglineerr, rpc）,使用,分隔， showLog 设置为 true 时，此项配置生效 buildFlags 构建 go 程序时传给 go 编译器的标志，如果需要使用构建标记（e.g. go build -tags=whatever_tag）在参数 buildFlags 里写入 -tags=whatever_tag&quot; 即可，支持多标签，使用单引号将标签包围,例如： &ldquo;-tags=&lsquo;first_tag second_tag third_tag&rsquo;&rdquo; remotePath 远程调试程序的绝对路径，当 mode 设置为 remote 时有效 其中对应的常用VS code常用公用变量如下所示： 属性 介绍 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; ${workspaceFolder} 调试 VS Code 打开工作空间的根目录下的所有文件 ${file} 调试当前文件 ${fileDirname } 调试当前文件所在目录下的所有文件 具体的其他配置，请参考VS code 的官方文档  ]]></content></entry><entry><title>关于 Allen 博客</title><url>/about.html</url><categories/><tags/><content type="html"> 希望是无所谓有，无所谓无的，这正如地上的路。
其实地上本没有路，走的人多了，也便成了路。</content></entry><entry><title>站点示例</title><url>/flinks.html</url><categories/><tags/><content type="html"> 如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
- name: Hugo-NexT desc: Hugo NexT 官方预览网站。 avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org</content></entry></search>
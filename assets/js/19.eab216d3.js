(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{333:function(e,t,n){"use strict";n.r(t);var r=n(7),a=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_12-useref基础用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-useref基础用法"}},[e._v("#")]),e._v(" 12 useRef基础用法")]),e._v(" "),t("h2",{attrs:{id:"useref概念解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useref概念解释"}},[e._v("#")]),e._v(" useRef概念解释")]),e._v(" "),t("p",[e._v("我们第七个要学习的Hook(钩子函数)是useRef，他的作用是“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象，并返回该对象的引用。该引用在组件整个生命周期中都固定不变，该引用并不会随着组件重新渲染而失效。")]),e._v(" "),t("p",[e._v("上面这段话，就算你认真读几遍，估计也是一头雾水，到底说的是啥？"),t("br"),e._v("\n我也实在想不出其他更加通俗的语言来描述useRef，不过经过下面的详细分解描述，相信能帮到你来理解useRef。")]),e._v(" "),t("h5",{attrs:{id:"某些组件挂载完成或重新渲染完成后才拥有的某些对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#某些组件挂载完成或重新渲染完成后才拥有的某些对象"}},[e._v("#")]),e._v(" “某些组件挂载完成或重新渲染完成后才拥有的某些对象”：")]),e._v(" "),t("p",[e._v("这句话中的“某些对象”主要分为3种：JSX组件转换后对应的真实DOM对象、在useEffect中创建的变量、子组件内自定义的函数(方法)。")]),e._v(" "),t("p",[t("strong",[e._v("第1：JSX组件转换后对应的真实DOM对象")]),e._v("："),t("br"),e._v("\n举例：假设在JSX中，有一个输入框<input type='text' />，这个标签最终将编译转换成真正的html标签中的<input type='text'/>。"),t("br"),e._v("\n你应该知道以下几点："),t("br"),e._v("\n1、JSX中小写开头的组件看似和原生html标签相似，但是并不是真的原生标签，依然是react内置组件。"),t("br"),e._v("\n2、什么时候转换？ 虚拟DOM转化为真实DOM"),t("br"),e._v("\n3、什么时候可访问？组件挂载完成或重新渲染完成后")]),e._v(" "),t("p",[e._v("对于上面举例中的那个转换后的<input/> 真实DOM，只有组件挂载完成或重新渲染完成后才可以访问，它就就属于“某些组件挂载完成或重新渲染完成后才拥有的某些对象”。")]),e._v(" "),t("p",[e._v("特别强调：useRef只适合“勾住”小写开头的类似原生标签的组件。如果是自定义的react组件(自定义的组件必须大写字母开头)，那么是无法使用useRef的。")]),e._v(" "),t("p",[e._v("思考：如何获取这个 <input/> 真实DOM呢？"),t("br"),e._v("\n答：用useRef。")]),e._v(" "),t("p",[t("strong",[e._v("第2：在useEffect中创建的变量")]),e._v("："),t("br"),e._v("\n举例，请看以下代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("useEffect(() => {\n    let timer = setInterval(() => {\n        setCount(prevData => prevData +1);\n    }, 1000);\n    return () => {\n        clearInterval(timer);\n    }\n},[]);\n")])])]),t("p",[e._v("上述代码中，请注意这个timer是在useEffect中才定义的。")]),e._v(" "),t("p",[e._v("思考：useEffect 以外的地方，该如何获取这个 timer 的引用？"),t("br"),e._v("\n答：用useRef")]),e._v(" "),t("p",[t("strong",[e._v("第3：子组件内自定义的函数(方法)")]),t("br"),e._v("\n由于需要结合useImperativeHandle才可以实现，而useImperativeHandle目前还未学习，所以本章中不讨论这个怎么实现。"),t("br"),e._v("\n本章只讲前2中应用场景。")]),e._v(" "),t("h5",{attrs:{id:"并返回该对象的引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并返回该对象的引用"}},[e._v("#")]),e._v(" “并返回该对象的引用”：")]),e._v(" "),t("p",[e._v("上面的前2种情况，都提到用useRef来获取对象的引用。具体如何获取，稍后在useRef用法中会有演示。")]),e._v(" "),t("h5",{attrs:{id:"该引用在组件整个生命周期中都固定不变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#该引用在组件整个生命周期中都固定不变"}},[e._v("#")]),e._v(" “该引用在组件整个生命周期中都固定不变”：")]),e._v(" "),t("p",[e._v("假设通过useRef获得了该对象的引用，那么当react组件重新渲染后，如何保证该引用不丢失？"),t("br"),e._v("\n答：react在底层帮我们做了这个工作，我们只需要相信之前的引用可以继续找到目标对象即可。")]),e._v(" "),t("p",[e._v("请注意：React.createRef()也有useRef相似效果，但是React.createRef无法全部适用上面提到的3种情况。")]),e._v(" "),t("p",[e._v("让我们回到useRef基础学习中。")]),e._v(" "),t("h2",{attrs:{id:"useref是来解决什么问题的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useref是来解决什么问题的"}},[e._v("#")]),e._v(" useRef是来解决什么问题的？")]),e._v(" "),t("p",[e._v("答：useRef可以“获取某些组件挂载完成或重新渲染完成后才拥有的某些对象”的引用，且保证该引用在组件整个生命周期内固定不变，都能准确找到我们要找的对象。"),t("br"),e._v("\n具体已经在useRef中做了详细阐述，这里不再重复。")]),e._v(" "),t("p",[e._v("补充说明："),t("br"),e._v("\n1、useRef是针对函数组件的，如果是类组件则使用React.createRef()。"),t("br"),e._v("\n2、React.createRef()也可以在函数组件中使用。"),t("br"),e._v("\n只不过React.createRef创建的引用不能保证每次重新渲染后引用固定不变。如果你只是使用React.createRef“勾住”JSX组件转换后对应的真实DOM对象是没问题的，但是如果想“勾住”在useEffect中创建的变量，那是做不到的。")]),e._v(" "),t("p",[e._v("2者都想可以“勾住”，只能使用useRef。")]),e._v(" "),t("h2",{attrs:{id:"注意注意"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意注意"}},[e._v("#")]),e._v(" 注意注意")]),e._v(" "),t("p",[e._v("在后面useImperativeHandle的学习中，你会知道useRef还可以 “勾住并调用” 子组件内定义的函数(方法)。")]),e._v(" "),t("br"),e._v(" "),t("blockquote",[t("p",[e._v("以下内容更新于 2022.04.06")])]),e._v(" "),t("h2",{attrs:{id:"特别注意-修改-current-的值并不会触发组件重新渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特别注意-修改-current-的值并不会触发组件重新渲染"}},[e._v("#")]),e._v(" 特别注意：修改 .current 的值并不会触发组件重新渲染")]),e._v(" "),t("p",[e._v("在本文开头介绍 useRef  时用了这句话 “useRef 是“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象，并返回该对象的引用。”")]),e._v(" "),t("p",[e._v("也就是说 "),t("strong",[e._v("先有了 组件渲染，之后才更新了 useRef 中 .current 的值。")])]),e._v(" "),t("blockquote",[t("p",[e._v("也就是说 useRef 变量的 current 的值实际上是 组件渲染 后的一个副产品。")])]),e._v(" "),t("p",[t("strong",[e._v("这句话暗含了另外一层含义：主动更新 useRef 变量的 .current 的值并不会触发组件重新渲染。")])]),e._v(" "),t("p",[e._v("例如下面这个示例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import { useRef } from "react";\n\nexport default function MyButton() {\n  const countRef = useRef(0)\n\n  const handleClick = () => {\n    countRef.current = countRef.current + 1\n  };\n\n  return <button onClick={handleClick}>Click me {countRef.current}</button>;\n}\n')])])]),t("p",[e._v("实际运行就会发现，在点击事件中我们修改了 countRef.current 的值，尽管该值确实发生了变化，可是并不会触发组件的重新渲染。")]),e._v(" "),t("blockquote",[t("p",[e._v("使用 useState() 产生的变量值发生变化后，是会触发组件重新渲染的。")])]),e._v(" "),t("br"),e._v(" "),t("blockquote",[t("p",[e._v("以上内容更新于 2022.04.06")])]),e._v(" "),t("br"),e._v(" "),t("h2",{attrs:{id:"useref函数源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useref函数源码"}},[e._v("#")]),e._v(" useRef函数源码：")]),e._v(" "),t("p",[e._v("回到useRef的学习中，首先看一下React源码中的"),t("a",{attrs:{href:"https://github.com/facebook/react/blob/master/packages/react/src/ReactHooks.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("ReactHooks.js"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//备注：源码采用TypeScript编写，如果不懂TS代码，阅读起来稍显困难\nexport function useRef<T>(initialValue: T): {|current: T|} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n")])])]),t("p",[e._v("上述代码看不懂没关系，本系列教程只是讲述“如何使用Hook”，并不是“Hook源码分析”。^_^")]),e._v(" "),t("h2",{attrs:{id:"useref基本用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useref基本用法"}},[e._v("#")]),e._v(" useRef基本用法")]),e._v(" "),t("p",[e._v("useRef(initialValue)函数只有1个可选参数，该参数为默认“勾住”的对象。绝大多数实际的情况是，默认“勾住”的对象在JSX未编译前(组件挂载或重新渲染后)根本不存在，所以更多时候都会传一个 null 作为默认值。如果不传任何参数，那么react默认将参数设置为undefined。")]),e._v(" "),t("p",[e._v("就目前本人所理解的，日常使用过程中useRef(null)和useRef() 实际上是没有什么区别的。")]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("以下更新于 2020.12.10")]),e._v(" "),t("p",[t("strong",[e._v("补充一下 React + TypeScript 知识点：")])]),e._v(" "),t("p",[e._v("useRef(null) 和 useRef() 在 React + TypeScript 项目中还是有差别的。")]),e._v(" "),t("p",[e._v("假设我们要勾住一个 <canvas /> DOM元素，那么：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const canvasRef1 = useRef<HTMLCanvasElement>(null)\nconst canvasRef2 = useRef<HTMLCanvasElement>()\n")])])]),t("p",[e._v("上面代码中：")]),e._v(" "),t("ol",[t("li",[e._v("canvasRef1.current 的类型为：HTMLCanvasElement | null")]),e._v(" "),t("li",[e._v("canvasRef2.current 的类型为：HTMLCanvasElement | null | undefined")])]),e._v(" "),t("p",[e._v("以上更新于 2020.12.10")]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("第2遍强调：本文提到的组件，默认都是指小写开头的类似原生标签的组件，不可以是自定义组件。")]),e._v(" "),t("p",[e._v("接下来具体说说useRef关联对象的2种用法："),t("br"),e._v("\n1、针对 JSX组件，通过属性 ref={xxxRef} 进行关联。"),t("br"),e._v("\n2、针对 useEffect中的变量，通过 xxxRef.current 进行关联。")]),e._v(" "),t("h5",{attrs:{id:"代码形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码形式"}},[e._v("#")]),e._v(" 代码形式：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("//先定义一个xxRef引用变量，用于“勾住”某些组件挂载完成或重新渲染完成后才拥有的某些对象\nconst xxRef = useRef(null);\n\n//针对 JSX组件，通过属性 ref={xxxRef} 进行关联\n<xxx ref={xxRef} />\n\n//针对 useEffect中的变量，通过 xxxRef.current 进行关联\nuseEffect(() => {\n   xxRef.current = xxxxxx;\n},[]);\n")])])]),t("h5",{attrs:{id:"拆解说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拆解说明"}},[e._v("#")]),e._v(" 拆解说明：")]),e._v(" "),t("p",[e._v("1、具体讲解已在上面示例代码中做了多项注释，此处不再重复；")]),e._v(" "),t("h4",{attrs:{id:"ref-补充说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ref-补充说明"}},[e._v("#")]),e._v(" 'ref'补充说明")]),e._v(" "),t("p",[e._v("1、组件的 ref 为特殊属性名，他并不存在组件属性传值的 props 中。"),t("br"),e._v("\n2、如果给一个组件设定了 ref 属性名，但是对应的值却不是由 useRef 创建的，那么实际运行中会收到react的报错，无法正常渲染。")]),e._v(" "),t("h4",{attrs:{id:"xxx-补充说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#xxx-补充说明"}},[e._v("#")]),e._v(" '<xxx>'补充说明")]),e._v(" "),t("p",[e._v("1、useRef只能针对react中小写开头的类似原生标签的组件，所以这里用的是 <xxx> 而不是 <Xxx>。")]),e._v(" "),t("h4",{attrs:{id:"xxxref-current-补充说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#xxxref-current-补充说明"}},[e._v("#")]),e._v(" 'xxxRef.current'补充说明")]),e._v(" "),t("p",[e._v("1、当需要使用“勾住”的对象时，也是通过xxRef.current来获取该对象的。")]),e._v(" "),t("h2",{attrs:{id:"useref使用示例1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useref使用示例1"}},[e._v("#")]),e._v(" useRef使用示例1：")]),e._v(" "),t("p",[e._v("若我们有一个组件，该组件只有一个输入框，我们希望当该组件挂载到网页后，自动获得输入焦点。")]),e._v(" "),t("p",[e._v("需求分析："),t("br"),e._v("\n1、我们可以很轻松使用<input >创建出这个输入框。"),t("br"),e._v("\n2、需要使用useRef “勾住”这个输入框，当它被挂载到网页后，通过操作原生html的方法，将焦点赋予该输入框上。")]),e._v(" "),t("p",[e._v("完整代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import React,{useEffect,useRef} from 'react'\n\nfunction Component() {\n  //先定义一个inputRef引用变量，用于“勾住”挂载网页后的输入框\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    //inputRef.current就是挂载到网页后的那个输入框，一个真实DOM，因此可以调用html中的方法focus()\n    inputRef.current.focus();\n  },[]);\n\n  return <div>\n      {/* 通过 ref 属性将 inputRef与该输入框进行“挂钩” */}\n      <input type='text' ref={inputRef} />\n    </div>\n}\nexport default Component\n")])])]),t("p",[e._v("注意："),t("br"),e._v("\n1、在给组件设置 ref 属性时，只需传入 inputRef，千万不要传入 inputRef.current。"),t("br"),e._v("\n2、在“勾住”渲染后的真实DOM输入框后，能且只能调用原生html中该标签拥有的方法。")]),e._v(" "),t("h2",{attrs:{id:"useref使用示例2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useref使用示例2"}},[e._v("#")]),e._v(" useRef使用示例2：")]),e._v(" "),t("p",[e._v("若我们有一个组件，该组件的功能需求如下："),t("br"),e._v("\n1、组件中有一个变量count，当该组件挂载到网页后，count每秒自动 +1。"),t("br"),e._v("\n2、组件中有一个按钮，点击按钮可以停止count自动+1。")]),e._v(" "),t("p",[e._v("需求分析："),t("br"),e._v("\n1、声明内部变量count用 useState"),t("br"),e._v("\n2、可以在useEffect 通过setInterval创建一个计时器timer，实现count每秒自动 +1"),t("br"),e._v("\n3、当组件卸载前，需要通过 clearInterval 将timer清除"),t("br"),e._v("\n4、按钮点击处理函数中，也要通过 clearInterval 将timer清除")]),e._v(" "),t("p",[e._v("假设我们不使用useRef，那该如何实现？")]),e._v(" "),t("p",[e._v("为了确保timer可以被useEffect以外地方也能访问，我们通常做法是将timer声明提升到useEffect以外。"),t("br"),e._v("\n代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import React,{useState,useEffect} from 'react'\n\nfunction Component() {\n  const [count,setCount] = useState(0);\n  const [timer,setTimer] = useState(null); //单独声明定义timer，目的是为了让组件内所有地方都可以访问到timer\n\n  useEffect(() => {\n    //需要用setTimer()包裹住 setInterval()\n    setTimer(setInterval(() => {\n        setCount((prevData) => {return prevData +1});\n    }, 1000));\n    return () => {\n      //清除掉timer\n      clearInterval(timer);\n    }\n  },[]);\n\n  const clickHandler = () => {\n    //清除掉timer\n    clearInterval(timer);\n  };\n\n  return (\n    <div>\n        {count}\n        <button onClick={clickHandler} >stop</button>\n    </div>\n  )\n}\n\nexport default Component\n")])])]),t("p",[e._v("如果使用useRef，该如何实现？\n代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import React,{useState,useEffect,useRef} from 'react'\n\nfunction Component() {\n  const [count,setCount] =  useState(0);\n  const timerRef = useRef(null);//先定义一个timerRef引用变量，用于“勾住”useEffect中通过setIntervale创建的计时器\n\n  useEffect(() => {\n    //将timerRef.current与setIntervale创建的计时器进行“挂钩”\n    timerRef.current = setInterval(() => {\n        setCount((prevData) => { return prevData +1});\n    }, 1000);\n    return () => {\n        //通过timerRef.current，清除掉计时器\n        clearInterval(timerRef.current);\n    }\n  },[]);\n\n  const clickHandler = () => {\n    //通过timerRef.current，清除掉计时器\n    clearInterval(timerRef.current);\n  };\n\n  return (\n    <div>\n        {count}\n        <button onClick={clickHandler} >stop</button>\n    </div>\n  )\n}\n\nexport default Component\n")])])]),t("p",[t("strong",[e._v("两种实现方式对比：")])]),e._v(" "),t("p",[e._v("1、两种实现方式最主要的差异地方在于 如何创建组件内对计时器的引用。"),t("br"),e._v("\n2、两种创建引用的方式，分别是：用useState创建的timer、用useRef创建的timerRef"),t("br"),e._v("\n3、在使用setInterval时，相对来说timerRef.current更加好用简单，结构清晰，不需要像 setTimer那样需要再多1层包裹。"),t("br"),e._v("\n4、timer更像是一种react对计时器的映射，而timerRef直接就是真实DOM中计时器的引用，timerRef能够调用更多的原生html中的JS方法和属性。")]),e._v(" "),t("p",[t("strong",[e._v("结论：")]),t("br"),e._v("\n1、如果需要对渲染后的DOM节点进行操作，必须使用useRef。"),t("br"),e._v("\n2、如果需要对渲染后才会存在的变量对象进行某些操作，建议使用useRef。")]),e._v(" "),t("p",[e._v("第3遍强调：useRef只适合“勾住”小写开头的类似原生标签的组件。如果是自定义的react组件(自定义的组件必须大写字母开头)，那么是无法使用useRef的。")]),e._v(" "),t("br"),e._v(" "),t("blockquote",[t("p",[e._v("以下内容更新于 2022.05.20")])]),e._v(" "),t("h2",{attrs:{id:"useref使用示例3-父组件调用子组件中的函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useref使用示例3-父组件调用子组件中的函数"}},[e._v("#")]),e._v(" useRef使用示例3：父组件调用子组件中的函数")]),e._v(" "),t("p",[t("strong",[e._v("首先特别强调：除非情况非常特殊，否则一般情况下都不要采用 父组件调用子组件的函数 这种策略。")])]),e._v(" "),t("br"),e._v(" "),t("p",[t("strong",[e._v("使用 useRef 实现父组件调用子组件中的函数 实现思路：")])]),e._v(" "),t("ol",[t("li",[t("p",[e._v("父组件中通过 useRef 定义一个钩子变量，例如 childFunRef")])]),e._v(" "),t("li",[t("p",[e._v("父组件通过参数配置，将 childFunRef 传递给子组件")])]),e._v(" "),t("li",[t("p",[e._v("子组件在自己的 useEffect() 中定义一个函数，例如 doSomting()")]),e._v(" "),t("blockquote",[t("p",[e._v("划重点：一定要在 useEffect() 中定义 doSomting()，不能直接在子组件内部定义。")]),e._v(" "),t("p",[e._v("因为如果 doSomting() 定义在子组件内部，那么就会造成每一次组件刷新都会重新生成一份 doSomthing()")])])]),e._v(" "),t("li",[t("p",[e._v("然后将 doSomting() 赋值到 childFunRef.current 中")])]),e._v(" "),t("li",[t("p",[e._v("这样，当父组件想调用子组件中的 doSomting() 时，可执行 childFunRef.current.doSomting()")])])]),e._v(" "),t("br"),e._v(" "),t("p",[e._v("具体示例代码：")]),e._v(" "),t("p",[t("strong",[e._v("ParentComponent")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import { useRef } from "react";\nimport ChildComponent from "./child";\n\nconst ParentComponent = () => {\n  const childFunRef = useRef();\n  const handleOnClick = () => {\n    if (childFunRef.current) {\n      childFunRef.current.doSomething();\n    }\n  };\n  return (\n    <div>\n      <ChildComponent funRef={childFunRef} />\n      <button onClick={handleOnClick}>执行子项的doSomething()</button>\n    </div>\n  );\n};\n\nexport default ParentComponent;\n')])])]),t("br"),e._v(" "),t("p",[t("strong",[e._v("ChildComponent")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import { useEffect, useState } from "react";\n\nconst ChildComponent = ({ funRef }) => {\n  const [num, setNum] = useState(0);\n  useEffect(() => {\n    const doSomething = () => {\n      setNum(Math.floor(Math.random() * 100));\n    };\n    funRef.current = { doSomething }; //在子组件中修改父组件中定义的childFunRef的值\n  }, [funRef]);\n  return <div>{num}</div>;\n};\n\nexport default ChildComponent;\n')])])]),t("br"),e._v(" "),t("p",[t("strong",[e._v("特别说明：")])]),e._v(" "),t("ol",[t("li",[t("p",[e._v("下一章要讲解的 useImperativeHandle 也是用来实现 父组件调用子组件内定义的函数的。")])]),e._v(" "),t("li",[t("p",[e._v("再次强调，如非必要，真的不要使用 父组件调用子组件内函数 这种策略。")]),e._v(" "),t("blockquote",[t("p",[e._v("最近我遇到了一个需求，子组件是一个第三方写好的轮播图，父组件需要调用这个轮播图的 next() 的函数来切换下一张，所以才使用了这种策略。")])])])]),e._v(" "),t("blockquote",[t("p",[e._v("以上内容更新于 2022.05.20")])]),e._v(" "),t("br"),e._v(" "),t("hr"),e._v(" "),t("blockquote",[t("p",[e._v("以下内容更新于2020.11.18")])]),e._v(" "),t("h4",{attrs:{id:"在-typescript-中使用-useref-创建计时器注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在-typescript-中使用-useref-创建计时器注意事项"}},[e._v("#")]),e._v(" 在 TypeScript 中使用 useRef 创建计时器注意事项：")]),e._v(" "),t("p",[e._v("在上面代码示例中，请注意这一行代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("timerRef.current = setInterval(() => {\n        setCount((prevData) => { return prevData +1});\n    }, 1000);\n")])])]),t("p",[e._v("如果是在 TS 语法下，上面的代码会报错误：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("不能将类型“Timeout”分配给类型“number”。\n")])])]),t("p",[t("strong",[e._v("Timeout ???")])]),e._v(" "),t("p",[e._v("造成这个错误提示的原因是：")]),e._v(" "),t("ol",[t("li",[e._v("TypeScript 是运行在 Nodejs 环境下的，TS 编译之后的代码是运行在浏览器环境下的。")]),e._v(" "),t("li",[e._v("Nodejs 和浏览器中的 window 他们各自实现了一套自己的 setInterval")]),e._v(" "),t("li",[e._v("原来代码 timerRef.current = setInterval( ... ) 中 setInterval 会被 TS 认为是 Nodejs 定义的 setInterval，而  Nodejs 中 setInterval 返回的类型就是 NodeJS.Timeout。")]),e._v(" "),t("li",[e._v("所以，我们需要将上述代码修改为：timerRef.current = window.setInterval( ... )，明确我们调用的是 window.setInterval，而不是 Nodejs 的 setInterval。")])]),e._v(" "),t("p",[t("strong",[e._v("附一个 TS 代码示例：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import React, { useRef, useEffect } from 'react'\n\nconst MyTemp = () => {\n    const timer = useRef<number | undefined>()\n\n    useEffect(() => {\n        timer.current = window.setInterval(() => {\n            console.log(0)\n        }, 1000)\n\n        return () => {\n            clearInterval(timer.current)\n        }\n    }, [])\n    return (\n        <div></div>\n    )\n}\n\nexport default MyTemp\n")])])]),t("blockquote",[t("p",[e._v("以上内容更新于2020.11.18")])]),e._v(" "),t("hr"),e._v(" "),t("blockquote",[t("p",[e._v("以下内容更新于2020.12.03")])]),e._v(" "),t("h4",{attrs:{id:"在-typescript-中给-useref-current-赋值的注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在-typescript-中给-useref-current-赋值的注意事项"}},[e._v("#")]),e._v(" 在 TypeScript 中给 useRef.current 赋值的注意事项")]),e._v(" "),t("p",[e._v("在 jsx 文件中，以下代码是不会有问题的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const myRef = useRef(null)\n...\nmyRef.current = xxxx\n")])])]),t("p",[e._v("但是，在我们使用 TypeScript 之后，按照习惯改成以下代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const myRef = useRef<Xxx>(null)\n...\nmyRef.current = xxx\n")])])]),t("p",[e._v("此时，会收到 TypeScript 的报错："),t("strong",[e._v('无法分配到 "current" ，因为 myRef.current 是只读属性。')])]),e._v(" "),t("p",[t("strong",[e._v("报错原因：")])]),e._v(" "),t("p",[e._v("React 的作者并没有规定使用 useRef(null) 之后 myRef.current 就不可以再修改了。")]),e._v(" "),t("p",[e._v("但是 TypeScript 的作者认为，若使用 useRef(null) 之后，myRef 就应该交由 React 来托管，外界不应该有权利去修改 myRef.current，因此此时会把 myRef.current 当做只读属性。")]),e._v(" "),t("p",[t("strong",[e._v("解决方式：")])]),e._v(" "),t("p",[e._v("解决方式1：不给 useRef 设置 null 这个默认值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const myRef = useRef<Xxx>()\n")])])]),t("p",[e._v("解决方式2：就是将原本的类型定义，修改成以下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const myRef = useRef<Xxx | null>(null)\n\n//或者是\n\nconst myRef = useRef<Xxx | undefined>()\n")])])]),t("p",[e._v("myRef.current 的数据类型，除了 Xxx 之外，再加上 null 或 undefined ，这样 TypeScript 就认为  myRef.current 可能中途会发生修改，因此不会再将其设置为只读属性，此时再去执行 "),t("code",[e._v("myRef.current = xxx")]),e._v(" 不再会报错。")]),e._v(" "),t("p",[t("strong",[e._v("验证一下：")])]),e._v(" "),t("p",[e._v("我们再去看看上面 2020.11.18 更新的 TypeScript 代码示例中：")]),e._v(" "),t("p",[e._v("由于将来需要执行 timer.current =  window.setInterval ( ... )，也就是说需要给 timer.current 赋值。")]),e._v(" "),t("p",[e._v("所以在定义时就使用以下方式，以确保 timer.current 不会被 TS 认为是只读属性：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const timer = useRef<number | undefined>()\n")])])]),t("blockquote",[t("p",[e._v("以上内容更新于2020.12.03")])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"那如何-勾住-自定义组件中的-小写开头的类似原生标签的组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#那如何-勾住-自定义组件中的-小写开头的类似原生标签的组件"}},[e._v("#")]),e._v(" 那如何“勾住”自定义组件中的“小写开头的类似原生标签的组件”？")]),e._v(" "),t("p",[e._v("答：使用React.forwardRef()。")]),e._v(" "),t("h5",{attrs:{id:"你是否思考过这个问题-自定义组件到底是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#你是否思考过这个问题-自定义组件到底是什么"}},[e._v("#")]),e._v(" 你是否思考过这个问题：自定义组件到底是什么？")]),e._v(" "),t("p",[e._v("首先看一下“小写开头的类似原生标签的组件”，例如<button>、<input >，我们很容易理解他是react内置的类似原生DOM的组件，最终都将直接转换成对应的真实DOM。")]),e._v(" "),t("p",[e._v("那自定义组件又该如何理解，如何定义呢？")]),e._v(" "),t("p",[e._v("假设我们有一个自定义组件<MyComponent>，那么有以下几点是可以肯定的："),t("br"),e._v("\n1、<MyComponent>内部return出去的，可以是小写开头的类似原生标签的组件，也可以是其他自定义组件。"),t("br"),e._v("\n2、无论嵌套多少次，最底层组件return出去的，一定是小写开头的类似原生标签的组件。"),t("br"),e._v("\n3、<MyComponent>内部一定创建了变量、处理函数等等。"),t("br"),e._v("\n4、挂载或渲染后的实际网页中，并不会存在<MyComponent>这个标签，存在的依然是各种原生html标签。")]),e._v(" "),t("p",[e._v("为了简化更加容易理解，暂时姑且先把“小写开头的类似原生标签的组件”直接当做“原生html标签”。"),t("br"),e._v("\n那么“自定义组件”和“原生html标签”究竟区别在哪里呢？")]),e._v(" "),t("p",[e._v("先不回答这个问题，再说另外一个问题：交互式html页面都有哪些构成？"),t("br"),e._v("\n答：有各种html标签 + JS对象(JS中定义的变量和函数)")]),e._v(" "),t("p",[e._v("那我们使用react开发页面，“原生html标签”有了，那还缺什么？ 当然是 JS对象(JS中定义的变量和函数)。")]),e._v(" "),t("p",[e._v("再回顾一下问题：“自定义组件”和“原生html标签”究竟区别在哪里呢？"),t("br"),e._v("\n答：“自定义组件”除了拥有“原生html标签”，还拥有JS对象(JS中定义的变量和函数)。")]),e._v(" "),t("p",[e._v("再回顾一下开始的疑问：自定义组件到底是什么？"),t("br"),e._v("\n答：其实根本不存在自定义组件，所谓自定义组件，只不过是react给我们的各种语法糖，react并没有创造另外一门语言，react整体就是原生JS的语法糖。")]),e._v(" "),t("p",[e._v("JSX语法 + Hook 组合起来，形成一个强大的语法糖，让你编写html标签和JS更加简便而已。\n语法糖的对象就是：原生html标签 + JS对象(JS中定义的变量和函数)。")]),e._v(" "),t("p",[e._v("这就解释了为啥自定义组件 return 出去的内容，最外层必须有一个原生html标签。 说白了，无论你怎么定义，折腾这个自定义组件，本质上都要保证这个自定义组件最终都能转换成一段原生html代码。")]),e._v(" "),t("p",[e._v("上面这一大段话都是“简单到不能再简单的道理”，但是你只有理解透这一层，理解自定义组件、理解react究竟是什么之后，你会对于学习React各种API和Hook才会更加容易理解和接受。")]),e._v(" "),t("p",[e._v("让我们回到 那如何“勾住”自定义组件中的“小写开头的类似原生标签的组件”？ 这个问题上来。")]),e._v(" "),t("h5",{attrs:{id:"react-forwardref-的具体用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-forwardref-的具体用法"}},[e._v("#")]),e._v(" React.forwardRef() 的具体用法")]),e._v(" "),t("p",[e._v("React.forwardRef()包裹住要输出的组件，且将第2个参数设置为 ref 即可，示例代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import React from 'react'\n\nconst ChildComponent = React.forwardRef((props,ref) => {\n  //子组件通过将第2个参数ref 添加到内部真正的“小写开头的类似原生标签的组件”中 \n  return <button ref={ref}>{props.label}</button>\n});\n\n/* 上面的子组件直接在父组件内定义了，如果子组件是单独的.js文件，则可以通过\n   export default React.forwardRef(ChildComponent) 这种形式  */\n\nfunction Forward() {\n  const ref = React.useRef();//父组件定义一个ref\n  const clickHandle = () =>{\n    console.log(ref.current);//父组件获得渲染后子组件中对应的DOM节点引用\n  }\n  return (\n    <div>\n        {/* 父组件通过给子组件添加属性 ref={ref} 将ref作为参数传递给子组件 */}\n        <ChildComponent label='child bt' ref={ref} />\n        <button onClick={clickHandle} >get child bt ref</button>\n    </div>\n  )\n}\nexport default Forward;\n")])])]),t("hr"),e._v(" "),t("p",[e._v("至此，关于useRef()基础用法、React.forwardRef()已经讲完。 这2个函数的掌握，会对下一个要讲的Hook：useImperativeHandle 非常有用。")])])}),[],!1,null,null,null);t.default=a.exports}}]);